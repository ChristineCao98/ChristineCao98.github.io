<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dynamic Programming</title>
    <url>/2021/01/22/first-blog/</url>
    <content><![CDATA[<h1 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h1><ul>
<li>想满足最优子结，子问题之间必须互相独立</li>
<li>状态转移方程</li>
</ul>
<ol>
<li>明确base case  </li>
<li>明确「状态」</li>
<li>明确「选择」</li>
<li>定义 dp 数组/函数的含义<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 初始化 base case</span><br><span class="line">dp[0][0][...] &#x3D; base</span><br><span class="line"># 进行状态转移</span><br><span class="line">for 状态1 in 状态1的所有取值：</span><br><span class="line">    for 状态2 in 状态2的所有取值：</span><br><span class="line">        for ...</span><br><span class="line">            dp[状态1][状态2][...] &#x3D; 求最值(选择1，选择2...)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>遍历方向</li>
</ul>
<ol>
<li>遍历的过程中，所需的状态必须是已经计算出来的。</li>
<li>遍历的终点必须是存储结果的那个位置。</li>
</ol>
<h2 id="子序列模板"><a href="#子序列模板" class="headerlink" title="子序列模板"></a>子序列模板</h2><ol>
<li>第一种思路模板是一个一维的 dp 数组：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int n &#x3D; array.length;</span><br><span class="line">int[] dp &#x3D; new int[n];</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">    for (int j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">        dp[i] &#x3D; 最值(dp[i], dp[j] + ...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>第二种思路模板是一个二维的 dp 数组：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int n &#x3D; arr.length;</span><br><span class="line">int[][] dp &#x3D; new dp[n][n];</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    for (int j &#x3D; 1; j &lt; n; j++) &#123;</span><br><span class="line">        if (arr[i] &#x3D;&#x3D; arr[j]) </span><br><span class="line">            dp[i][j] &#x3D; dp[i][j] + ...</span><br><span class="line">        else</span><br><span class="line">            dp[i][j] &#x3D; 最值(...)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这种思路运用相对更多一些，尤其是涉及两个字符串/数组的子序列。本思路中 dp 数组含义又分为「只涉及一个字符串」和「涉及两个字符串」两种情况。<blockquote>
<ol>
<li>涉及两个字符串/数组时（比如最长公共子序列），dp 数组的含义如下:<br>在子数组arr1[0..i]和子数组arr2[0..j]中，我们要求的子序列（最长公共子序列）长度为dp[i][j]。</li>
<li>只涉及一个字符串/数组时，dp 数组的含义如下:<br>在子数组array[i..j]中，我们要求的子序列的长度为dp[i][j]。<br>主要还是正确定义 dp 数组的含义，遇到子序列问题，首先想到两种动态规划思路，然后根据实际问题看看哪种思路容易找到状态转移关系。<br>另外，找到状态转移和 base case 之后，一定要<strong>观察 DP table，看看怎么遍历</strong>才能保证通过已计算出来的结果解决新的问题</li>
</ol>
</blockquote>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2>贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。<br>贪心选择性质：每一步都做出一个局部最优的选择，最终的结果就是全局最优。</li>
</ol>
<ul>
<li>区间调度算法<blockquote>
<ol>
<li>从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中结束最早的（end 最小）。</li>
<li>把所有与 x 区间相交的区间从区间集合 intvs 中删除。</li>
<li>重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。</li>
</ol>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>problem solving template</tag>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/01/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>StringBuffer类</title>
    <url>/2021/01/24/StringBuffer/</url>
    <content><![CDATA[<ul>
<li>The differece between String and StringBuffer<br>String的长度和内容不可变，StringBuffer可变，不会浪费太多资源  <a id="more"></a></li>
<li>Constructor  <ul>
<li>public StringBuffer()</li>
<li>public StringBuffer(int capacity)</li>
<li>public StringBuffer(String str)  </li>
</ul>
</li>
<li>Class Method<br>*<ul>
<li>public int capacity()</li>
<li>public int length() </li>
<li>添加功能<ul>
<li>public StringBuffer append(String str):可以添加任意数据类型，并返回StringBuffer本身</li>
<li>public StringBuffer insert(int offset, String str):在指定位置插入任意数据类型</li>
</ul>
</li>
<li>删除功能 <ul>
<li>public StringBuffer deleteCharAt(int index)</li>
<li>public StringBuffer delete(int start,int end):[start,end)</li>
</ul>
</li>
<li>替换功能  <ul>
<li>public StringBuffer replace(int start,int end,String str)</li>
</ul>
</li>
<li>翻转功能  <ul>
<li>public StringBuffer reverse()</li>
</ul>
</li>
<li>截取功能  <ul>
<li>public String substring(int start)</li>
<li>public String substring(int start,int end)//注意返回值是String</li>
</ul>
</li>
</ul>
</li>
<li>StringBuilder是与StringBuffer兼容的API，但不保证同步(线程不安全)</li>
<li>String是一种特殊的引用类型，只能把它当作基本型来看,可以将其看作常量值，其参数传递和基本类型的参数传递是一样的    </li>
</ul>
<pre><code>public class StringBufferDemo &#123;
public static void main(String[] args) &#123;
String s1 = &quot;hello&quot;;
String s2 = &quot;world&quot;;
System.out.println(s1 + &quot;---&quot; + s2);// hello---world
change(s1, s2);
System.out.println(s1 + &quot;---&quot; + s2);// hello---world


StringBuffer sb1 = new StringBuffer(&quot;hello&quot;);
StringBuffer sb2 = new StringBuffer(&quot;world&quot;);
System.out.println(sb1 + &quot;---&quot; + sb2);// hello---world
change(sb1, sb2);
System.out.println(sb1 + &quot;---&quot; + sb2);// hello---worldworld


&#125;


public static void change(StringBuffer sb1, StringBuffer sb2) &#123;
sb1 = sb2;
sb2.append(sb1);
&#125;


public static void change(String s1, String s2) &#123;
s1 = s2;
s2 = s1 + s2;
&#125;</code></pre>
<p>解释：<br><strong>在java中，对于不管是基本类型还是引用类型，采用的都是值调用</strong></p>
<ul>
<li>call-by-value 值调用：将实际参数的内容拷贝到被调用方法。</li>
<li>call-by-reference 引用调用：将实际参数的地址作为形式参数的值被传递到被调用方法(拷贝到被调用方法的栈中)。<br>因此，对sb1=sb2;这个语句来说，只是将change方法栈内的引用sb1进行重定向，不会影响main方法中sb1引用指向的内容  </li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>basic syntax</tag>
      </tags>
  </entry>
  <entry>
    <title>arrays类&amp;基本包装类型&amp;Random类</title>
    <url>/2021/01/24/arrays/</url>
    <content><![CDATA[<h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><ul>
<li>概述<br>根据数组进行操作的工具类  </li>
<li>Class Method  <ul>
<li>public static String toString(T&lt;&gt; a)</li>
<li>public static void sort(T&lt;&gt; a)</li>
<li>public static int binarySearch(T&lt;&gt; a,T key)<h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2>为了对基本数据类型进行更多更方便的操作，Java针对每一种基本数据类型提供了对应的类类型–包装类    <table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
</tbody></table>
<a id="more"></a>
<h3 id="Integer类"><a href="#Integer类" class="headerlink" title="Integer类"></a>Integer类</h3></li>
</ul>
</li>
<li>构造方法  <ul>
<li>public Integer(int i)</li>
<li>public Integer(String str)//str必须由数字字符串组成  </li>
</ul>
</li>
<li>Class Method  <ul>
<li>Conversion between int and String<ul>
<li>public static String toString(int num)//int -&gt; String</li>
<li>public static int parseInt(String str)//String -&gt; int</li>
</ul>
</li>
<li>public int intValue()//Integer -&gt; int</li>
<li>public static Integer valueOf(int num)//int -&gt; Integer</li>
<li>public static Integer valueOf(String str)//String -&gt; Integer</li>
<li>十进制到其他进制  <ul>
<li>public static String toString(int i,int radix)//radix为进制数，进制的范围是2-36</li>
</ul>
</li>
<li>其他进制到十进制  <ul>
<li>public static int parseInt(String str,int radix)</li>
</ul>
</li>
</ul>
</li>
<li>JDK新特性  <ul>
<li>自动装箱<br>把基本类型转换为包装类型  </li>
<li>自动拆箱<br>把包装类型转换为基本类型<h3 id="Character类"><a href="#Character类" class="headerlink" title="Character类"></a>Character类</h3></li>
</ul>
</li>
<li>Constructor<br>public Character(char value)</li>
<li>Class Method<ul>
<li>public static boolean isUpperCase(char ch)</li>
<li>public static boolean isLowerCase(char ch)</li>
<li>public static boolean isDigit(char ch)</li>
<li>public static char toUpperCase(char ch)</li>
<li>public static char toLowerCase(char ch)<h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2></li>
</ul>
</li>
<li>Constructor<ul>
<li>public Random()//用当前时间的毫秒值作为默认种子</li>
<li>public Random(long seed)//给定种子后，每次得到的随机数是相同的 </li>
</ul>
</li>
<li>Class Method<ul>
<li>public int nextInt()//在int的范围内生成随机数</li>
<li>public int nextInt(int n)//[0,n)范围内生成随机数</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>basic syntax</tag>
      </tags>
  </entry>
  <entry>
    <title>Common Class</title>
    <url>/2021/01/24/commonclass/</url>
    <content><![CDATA[<h3 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h3><ul>
<li><p>概述<br>包含一些有用的类字段和方法，不能被实例化</p>
</li>
<li><p>Class Method  </p>
<ul>
<li>public static void gc()<br>System.gc()可用于垃圾回收，当使用它回收某个对象占用的内存之前，通过要求程序调用适当的方法清理资源。在没有明确指定资源清理的情况下，Java提供了默认机制来清理该对象的资源，就是调用Object类的finalize()方法()。finalize()方法的作用是释放一个对象占用的内存空间时，会被JVM调用，而子类重写该方法，就可以清理对象占用的资源，通过super.finalize()的方式可以实现从下到上的finalize()方法的调用，即先释放自己的资源再去释放父类的资源。<br>但是不要在程序中频繁地调用垃圾回收，因为每一次执行垃圾回收，JVM都会强制启动垃圾回收器运行，这会耗费更多的系统资源，会与正常的java程序运行争抢资源。只有在执行大量的对象释放时才调用垃圾回收最好。</li>
<li>public static void exit(int status)<br>终止目前正在运行的JVM，参数用作状态码。根据惯例，非0的状态码表示异常终止  </li>
<li>public static long currentTimeMillis()//返回当前时间与协调世界时，1970年1月1日午夜之间的时间差(以毫秒为单位)  </li>
<li>public static void arraycopy(Object src,int srcPos,Object dest,int desPos,int length)//从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束(注意此方法名是不规范的)  <a id="more"></a>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] arr1&#x3D;&#123;1,2,3,4,5&#125;</span><br><span class="line">int[] arr2&#x3D;&#123;11,22,33,44,55&#125;</span><br><span class="line">System.arraycopy(arr1,1,arr2,2,2);&#x2F;&#x2F;arr2:&#123;11,22,2,3,55&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Date类-很多功能都被Calender替代了"><a href="#Date类-很多功能都被Calender替代了" class="headerlink" title="Date类(很多功能都被Calender替代了)"></a>Date类(很多功能都被Calender替代了)</h3></li>
<li><p>精确到毫秒</p>
</li>
<li><p>constructor </p>
<ul>
<li>public Date()//用当前毫秒值构造</li>
<li>public Date(long date)//用给定毫秒值构造</li>
</ul>
</li>
<li><p>class method</p>
<ul>
<li>public long getTime()//获取时间，以毫秒为单位  </li>
<li>public void setTime(long time)//设置时间  </li>
</ul>
</li>
</ul>
<h3 id="Calender类"><a href="#Calender类" class="headerlink" title="Calender类"></a>Calender类</h3><ul>
<li>public int get(int field)//返回给定日历字段的值，日历类中的每个日历字段都是静态的成员变量，并且是int类型</li>
<li>public static Calender getInstance()//注意这个getInstance()会创建一个子类对象  </li>
<li>public void add(int field,int amount)//在给定的字段中加上amount值  </li>
<li>public final void set(int year,int month,int day)//注意Calender的month是从0开始算的</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>basic syntax</tag>
      </tags>
  </entry>
  <entry>
    <title>errorhandling</title>
    <url>/2021/01/25/errorhandling/</url>
    <content><![CDATA[<h3 id="Java中的异常"><a href="#Java中的异常" class="headerlink" title="Java中的异常"></a>Java中的异常</h3><ul>
<li>Java的异常是class，Throwable是异常体系的根，它继承自Object。<ul>
<li>Throwable有两个体系：Error和Exception，Error表示严重的错误，程序对此一般无能为力。</li>
<li>而Exception则是运行时的错误，它可以被捕获并处理</li>
</ul>
</li>
<li>Java规定  <ul>
<li>必须捕获的异常，包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常称为Checked Exception</li>
<li>不需要捕获的异常，包括Error及其子类，RuntimeException及其子类。  </li>
</ul>
</li>
<li>在方法定义的时候，使用throws Xxx表示该方法可能抛出的异常类型。**<em>调用方**</em>在调用的时候，必须强制捕获这些异常，否则编译器会报错。<a id="more"></a>

</li>
</ul>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><ul>
<li><p>可以使用多个catch语句，每个catch分别捕获对应的Exception及其子类。JVM在捕获到异常后，会从上到下匹配catch语句，匹配到某个catch后，执行catch代码块，然后不再继续匹配。  </p>
</li>
<li><p>子类异常必须写在父类异常前面，否则父类异常就会先被捕获，子类异常不会被捕获</p>
</li>
<li><p>finally语句  </p>
<ul>
<li>finally语句不是必须的，可写可不写  </li>
<li>finally语句总是最后执行  </li>
<li>在catch中抛出异常，不会影响finally的执行。JVM会先执行finally，然后抛出异常。</li>
</ul>
</li>
<li><p>捕获异常可以用’|’拼在一起  </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">catch (IOException | NumberFormatException e)</span><br></pre></td></tr></table></figure>
<h3 id="assertion"><a href="#assertion" class="headerlink" title="assertion"></a>assertion</h3><ul>
<li>概述<br>是一种调试程序的方式  </li>
<li>例子  </li>
</ul>
<pre><code>void f(int x)&#123;
    assert x&gt;0;//断言条件x&gt;0预期为true。如果计算结果为false，则断言失败，抛出AssertionError。
    /*
    assert x&gt;0 : &quot;x must &gt;0&quot;;
    也可以添加上报错信息
    */
&#125;</code></pre>
<ul>
<li>特点  <ul>
<li> 断言失败时会抛出AssertionError，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。</li>
<li>JVM默认关闭断言指令，即遇到assert语句就自动忽略了，不执行。<br>要执行assert语句，必须给Java虚拟机传递-enableassertions（可简写为-ea）参数启用断言。所以，有断言的程序必须在命令行下运行才有效果</li>
<li>实际开发中，很少使用断言。更好的方法是编写单元测试  </li>
</ul>
</li>
</ul>
<h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><ul>
<li>概述<br>日志就是Logging，它的目的是为了取代System.out.println()进行程序调试  </li>
<li>功能  <ul>
<li>可以定义格式，重定向到文件等</li>
<li>可以存档，便于追踪问题</li>
<li>可以按级别分类，便于打开或关闭某些级别</li>
<li>可以根据配置文件调整日志，无需修改代码 </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>core learning</tag>
      </tags>
  </entry>
  <entry>
    <title>var&amp; StringJoiner类</title>
    <url>/2021/01/25/var/</url>
    <content><![CDATA[<h3 id="var关键字"><a href="#var关键字" class="headerlink" title="var关键字"></a>var关键字</h3><ul>
<li>var 是java10的新特性，用来定义局部变量  </li>
<li>在定义局部变量时，任意什么类型都可以用var定义变量的类型会根据所赋的值来判断</li>
<li>var 定义变量必须赋初始值</li>
</ul>
<h3 id="StringJoiner类"><a href="#StringJoiner类" class="headerlink" title="StringJoiner类"></a>StringJoiner类</h3><ul>
<li>作用<br>高效拼接字符  </li>
<li>实例   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String[] names &#x3D; &#123;&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;&#125;;</span><br><span class="line">        var sj &#x3D; new StringJoiner(&quot;, &quot;);</span><br><span class="line">        for (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output: Bob, Alice, Grace   </p>
<p>还可在Constructor指定开头和结尾：<br>var sj=new StringJoiner(String deli,String start,String end)  </p>
<ul>
<li>String的静态方法join()<br>在不需要指定开头和结尾时用此方法更方便  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    String[] names&#x3D;&#123;&quot;I&quot;,&quot;l&quot;,&quot;u&quot;&#125;;</span><br><span class="line">    String s&#x3D;String.join(&quot; ,&quot;,names);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>core learning</tag>
      </tags>
  </entry>
  <entry>
    <title>992. Subarrays with K Different Integers</title>
    <url>/2021/01/26/992_leetocde/</url>
    <content><![CDATA[<p>Using two windows, one to calculate the number of subarrays with exactly k different integers(M), the other with k-1 integers(N).<br>Each time slide to the right by one element, update the two windows, and increment the result by M-N, it is illustrated in the diagram as follows.<br><img src="/images/post_images/992_diagram1.png" alt="diagram1"></p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>sliding window</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>collections</title>
    <url>/2021/01/25/collections/</url>
    <content><![CDATA[<h3 id="Collection-概述"><a href="#Collection-概述" class="headerlink" title="Collection 概述"></a>Collection 概述</h3><ul>
<li>java.util包提供了集合类：Collection，它是除Map外所有其他集合类的根接口  </li>
<li>主要包括三种集合类型  <ul>
<li>List：一种有序列表的集合</li>
<li>Set：一种保证没有重复元素的集合</li>
<li>Map：一种通过键值（key-value）查找的映射表集合  <a id="more"></a>

</li>
</ul>
</li>
</ul>
<h3 id="List类"><a href="#List类" class="headerlink" title="List类"></a>List类</h3><ul>
<li>主要的接口方法  <ul>
<li>在末尾添加一个元素：boolean add(E e)</li>
<li>在指定索引添加一个元素：boolean add(int index, E e)</li>
<li>删除指定索引的元素：int remove(int index)</li>
<li>删除某个元素：int remove(Object e)</li>
<li>获取指定索引的元素：E get(int index)</li>
<li>获取链表大小（包含元素的个数）：int size()</li>
</ul>
</li>
<li>List允许添加null</li>
<li>要坚持使用迭代器遍历list<ul>
<li>Iterator对象有两个方法：boolean hasNext()判断是否有下一个元素，E next()返回下一个元素</li>
<li>只要实现了Iterable接口的集合类都可以直接用for each循环来遍历(Iterable接口定义了一个Iterator<E> iterator()方法，强迫集合类必须返回一个Iterator实例)</li>
</ul>
</li>
<li>复写equals方法  <ul>
<li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等</li>
<li>用instanceof判断传入的待比较的Object是不是当前类型，如果是，继续比较，否则返回false</li>
<li>对引用类型用Objects.equals()比较(省去了判断null的麻烦)，对基本类型直接用==比较</li>
</ul>
</li>
</ul>
<h3 id="Map类"><a href="#Map类" class="headerlink" title="Map类"></a>Map类</h3><ul>
<li>遍历   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;遍历key</span><br><span class="line">    for(E key:map.keySet())</span><br><span class="line">    &#x2F;&#x2F;同时遍历key和value</span><br><span class="line">    for(Map.EntrySet(E1,E2) entry:map.entrySet())&#123;</span><br><span class="line">        E1 key&#x3D;entry.getKey();</span><br><span class="line">        E2 value&#x3D;entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>重写equals方法<br>在Map的内部，对key做比较是通过equals()实现的，这一点和List查找元素需要正确覆写equals()是一样的，即正确使用Map必须保证：作为key的对象必须正确覆写equals()方法。  </p>
</li>
<li><p>重写hashCode方法<br>作为key的对象必须正确覆写hashCode()方法，且hashCode()方法要严格遵循以下规范：</p>
<ul>
<li>如果两个对象相等，则两个对象的hashCode()必须相等；</li>
<li>如果两个对象不相等，则两个对象的hashCode()尽量不要相等。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">  String firstName;</span><br><span class="line">  String lastName;</span><br><span class="line">  int age;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  int hashCode() &#123;</span><br><span class="line">      int h &#x3D; 0;</span><br><span class="line">      h &#x3D; 31 * h + firstName.hashCode();&#x2F;&#x2F;使用31*h的目的是为了尽量把不同的Person实例的hashCode()均匀分布到整个int范围</span><br><span class="line">      h &#x3D; 31 * h + lastName.hashCode();</span><br><span class="line">      h &#x3D; 31 * h + age;</span><br><span class="line">      return h;</span><br><span class="line">      &#x2F;&#x2F;return Objects.hash(firstName, lastName, age);</span><br><span class="line">      &#x2F;&#x2F;借助Objects.hash()方法可以避免NullPointerException</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>TreeSet和TreeMap的存储都是有序的，添加的元素必须正确实现Comparable接口，如果没有实现Comparable接口，那么创建TreeSet或TreeMap时必须传入一个Comparator对象。</p>
</li>
</ul>
<h3 id="Queue类"><a href="#Queue类" class="headerlink" title="Queue类"></a>Queue类</h3><ul>
<li>它和List的区别在于，List可以在任意位置添加和删除元素，而Queue只有两个操作：<ul>
<li>把元素添加到队列末尾；</li>
<li>从队列头部取出元素。</li>
</ul>
</li>
<li>方法  <ul>
<li>int size()：获取队列长度；</li>
<li>boolean add(E)/boolean offer(E)：添加元素到队尾；</li>
<li>E remove()/E poll()：获取队首元素并从队列中删除；</li>
<li>E element()/E peek()：获取队首元素但并不从队列中删除。</li>
<li>*a/b,在操作失败时，a方法会throw exception,b方法返回null或false**</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>core learning</tag>
      </tags>
  </entry>
  <entry>
    <title>IOstream</title>
    <url>/2021/01/26/IOstream/</url>
    <content><![CDATA[<h3 id="File对象"><a href="#File对象" class="headerlink" title="File对象"></a>File对象</h3><ul>
<li>构造时需要传入文件路径(可以是绝对路径也可以是相对路径)  </li>
<li><em>注意Windows平台使用\作为路径分隔符，在Java字符串中需要用两个\表示一个\*</em> </li>
<li>class method<ul>
<li>To get the path<ul>
<li>String getPath()</li>
<li>String getAbsolutePath()</li>
<li>String getCanonicalPath()<br>Absolute path can be shown as ‘C:\Windows\System32\..\notepad.exe’，canonical path is the path that transforms ‘.’into standard absolute path ‘C:\Windows\notepad.exe’.<a id="more"></a></li>
</ul>
</li>
</ul>
</li>
<li>文件和目录<br>File对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个File对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个File对象，并不会导致任何磁盘操作。只有当我们调用File对象的某些方法的时候，才真正进行磁盘操作。 <ul>
<li>用File对象获取到一个文件时，还可以进一步判断文件的权限和大小：  <ul>
<li>boolean canRead()：是否可读；</li>
<li>boolean canWrite()：是否可写；</li>
<li>boolean canExecute()：是否可执行；</li>
<li>long length()：文件字节大小。</li>
</ul>
</li>
</ul>
</li>
<li>创建和删除<ul>
<li>文件<ul>
<li>当File对象表示一个文件时，可以通过createNewFile()创建一个新文件，用delete()删除该文件</li>
<li>有些时候，程序需要读写一些临时文件，File对象提供了createTempFile()来创建一个临时文件，以及deleteOnExit()在JVM退出时自动删除该文件</li>
</ul>
</li>
<li>目录<br>和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：<ul>
<li>boolean mkdir()：创建当前File对象表示的目录；</li>
<li>boolean mkdirs()：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；</li>
<li>boolean delete()：删除当前File对象表示的目录，当前目录必须为空才能删除成功。  </li>
</ul>
</li>
</ul>
</li>
<li>遍历文件和目录  <ul>
<li>String[] list()(文件名)  </li>
<li>File[] listFiles()(提供了一系列重载方法，可以过滤不想要的文件和目录)(完整路径)  </li>
</ul>
</li>
</ul>
<h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><ul>
<li><p>概述<br>InputStream就是Java标准库提供的最基本的输入流，它是一个抽象类，是所有输入流的超类。</p>
</li>
<li><p>成员方法  </p>
<ul>
<li>public abstract int read() throws IOException;<br>读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1</li>
</ul>
</li>
<li><p>FileInputStream是InputStream的一个子类。顾名思义，FileInputStream就是从文件流中读取数据。  </p>
</li>
<li><p>InputStream和OutputStream都是通过close()方法来关闭流。关闭流就会释放对应的底层资源。(在计算机中，类似文件、网络端口这些资源，都是由操作系统统一管理的。应用程序在运行的过程中，如果打开了一个文件进行读写，完成后要及时地关闭，以便让操作系统把资源释放掉，否则，应用程序占用的资源会越来越多，不但白白占用内存，还会影响其他应用程序的运行。)   </p>
<ul>
<li>方法一：try finally</li>
<li>方法二：try(resource)  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void readFile() throws IOException &#123;</span><br><span class="line">  try (InputStream input &#x3D; new FileInputStream(&quot;src&#x2F;readme.txt&quot;)) &#123;</span><br><span class="line">      int n;</span><br><span class="line">      while ((n &#x3D; input.read()) !&#x3D; -1) &#123;</span><br><span class="line">          System.out.println(n);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; &#x2F;&#x2F; 编译器在此自动为我们写入finally并调用close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>缓冲<br>在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。<br>InputStream提供了两个重载方法来支持读取多个字节：</p>
</li>
<li><p>int read(byte[] b)：读取若干字节并填充到byte[]数组，返回读取的字节数</p>
</li>
<li><p>int read(byte[] b, int off, int len)：指定byte[]数组的偏移量和最大填充数  需要先定义一个byte[]数组作为缓冲区，read()方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。read()方法的返回值不再是字节的int值，而是返回实际读取了多少个字节。如果返回-1，表示没有更多的数据了。  </p>
</li>
<li><p>Blocking<br>Reading method is blocking, the next line will not be executed until the read method is finished  </p>
</li>
<li><p>ByteArrayInputStream类<br>把一个byte[]数组在内存中变成一个InputStream，在内存中模拟一个InputStream。测试的时候，可以用它来构造一个InputStream(这样就不需要用真实的文本文件测试)  </p>
</li>
</ul>
<h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><ul>
<li>概述<br>OutputStream就是Java标准库提供的最基本的输出流，它是一个抽象类，是所有输出流的超类。</li>
<li>成员方法<br>public abstract void write(int b) throws IOException;<br>虽然传入的是int参数，但只会写入一个字节，即只写入int最低8位表示字节的部分（相当于b &amp; 0xff）。  </li>
<li>OutputStream还提供了一个flush()方法，它的目的是将缓冲区的内容真正输出到目的地。<br>作用：因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个byte[]数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的  <ul>
<li>通常情况下，我们不需要调用这个flush()方法，因为缓冲区写满了OutputStream会自动调用它，并且，在调用close()方法关闭OutputStream之前，也会自动调用flush()方法。  </li>
<li>但如果是聊条软件等需要实时输出的程序中，每发送一条消息就需要flush一次  </li>
</ul>
</li>
<li>一次性写入若干字节可以用OutputStream提供的重载方法void write(byte[])来实现  </li>
</ul>
<h3 id="serialize"><a href="#serialize" class="headerlink" title="serialize"></a>serialize</h3><ul>
<li>概述<br>序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。</li>
<li>作用<br>序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。  </li>
<li>一个Java对象要能序列化，必须实现一个特殊的java.io.Serializable接口  </li>
</ul>
<h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><ul>
<li>Reader是Java的IO库提供的另一个输入流接口  </li>
<li>InputStram和Reader<br>InputStream是一个字节流，即以byte为单位读取，而Reader是一个字符流，即以char为单位读取<ul>
<li>InputStream -&gt; Reader  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 持有InputStream:</span><br><span class="line">  InputStream input &#x3D; new FileInputStream(&quot;src&#x2F;readme.txt&quot;);</span><br><span class="line">  &#x2F;&#x2F; 变换为Reader:</span><br><span class="line">  Reader reader &#x3D; new InputStreamReader(input, &quot;UTF-8&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3>Writer是带编码转换器的OutputStream，它把char转换为byte并输出。  </li>
</ul>
</li>
<li>class method<ul>
<li>写入一个字符（0~65535）：void write(int c)；</li>
<li>写入字符数组的所有字符：void write(char[] c)；</li>
<li>写入String表示的所有字符：void write(String s)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>core learning</tag>
      </tags>
  </entry>
  <entry>
    <title>reflection</title>
    <url>/2021/01/27/reflection/</url>
    <content><![CDATA[<h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><ul>
<li>当程序要使用某个类时，如果它还没被加载到内存，则系统会通过加载、连接、初始化三步来实现对这个类进行初始化<ul>
<li>加载  <ul>
<li>指将class文件读入内存，并为之创建一个Class对象  </li>
<li>任何类在使用时系统都会创建一个Class对象  </li>
</ul>
</li>
<li>连接  <ul>
<li>验证<br>是否有正确的内部结构，并和其他的类协调一致  </li>
<li>准备<br>负责为类的静态成员分配内存，并设置默认初始化值  </li>
<li>解析<br>将类中二进制数据中的符号引用替换为直接引用</li>
</ul>
</li>
<li>初始化  </li>
</ul>
</li>
<li>类的初始化时机<ul>
<li>创建类的实例  </li>
<li>访问类的静态变量或为其赋值  </li>
<li>调用类的静态方法  </li>
<li>使用反射方式强制创建某个类或接口对应的Java.lang.Class对象  </li>
<li>初始化某个类的子类  </li>
<li>直接使用Java.exe命令来运行某个子类  <a id="more"></a>

</li>
</ul>
</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li>概述  <ul>
<li>负责将.class文件加载到内存中，并为之生成对应的Class对象  </li>
</ul>
</li>
<li>组成  <ul>
<li>BootStrap ClassLoader<br>负责java核心类的加载(比如System,String等)</li>
<li>Extension ClassLoader<br>负责JRE扩展目录中jar包的加载</li>
<li>System ClassLoader<br>负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径  </li>
</ul>
</li>
</ul>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><ul>
<li><p>java反射机制是在运行状态中，对于任意一个类，都能知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取信息以及动态调用对象的方法的功能被称为java语言的反射机制  </p>
</li>
<li><p>要想解剖一个类必须获取该类的字节码文件对象。而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象  </p>
</li>
<li><p>Class类  </p>
<ul>
<li>成员变量 Field</li>
<li>构造方法 Constructor</li>
<li>成员方法 Method</li>
<li>通过这三个对象调用相应的成员变量、构造方法和成员方法  </li>
</ul>
</li>
<li><p>获取Class文件对象的三种方式  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;method 1:getClass() method of Object class</span><br><span class="line">        A a&#x3D;new A();</span><br><span class="line">        Class c&#x3D;a.getClass();</span><br><span class="line">        &#x2F;&#x2F;method 2: static attribute of data type </span><br><span class="line">        Class c2&#x3D;A.class;</span><br><span class="line">        &#x2F;&#x2F;method 3: static method of Class class</span><br><span class="line">        &#x2F;&#x2F;public static Class forName(String className)</span><br><span class="line">        &#x2F;&#x2F;className must include the complete path </span><br><span class="line">        Class c3&#x3D;Class.forName(&quot;cn.net.A&quot;);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>开发中一般使用第三种，因为它的参数是字符串，可以配置到配置文件中  </p>
</li>
<li><p>通过反射获取构造方法  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; No-argument constructor</span><br><span class="line">    Class c1&#x3D;Class.forName(&quot;cn.net.A&quot;);</span><br><span class="line">    Constructor con&#x3D;c1.getConstructor();</span><br><span class="line">    Object obj&#x3D;con.newInstance();</span><br><span class="line">    &#x2F;&#x2F;Parameterized constructor</span><br><span class="line">    Class c2&#x3D;Class.forName(&quot;cn.net.A&quot;);</span><br><span class="line">    Constructor con&#x3D;c2.getConstructor(int.class,int.class);</span><br><span class="line">    Object obj&#x3D;con.newInstance(2,3);</span><br><span class="line">    &#x2F;&#x2F;private constructor</span><br><span class="line">    Class c3&#x3D;Class.forName(&quot;cn.net.A&quot;);</span><br><span class="line">    Constructor con&#x3D;c3.getDeclaredConstructor(int.class,int.class);</span><br><span class="line">    con.setAccessible(true);</span><br><span class="line">    Object obj&#x3D;con.newInstance(2,3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过反射获取成员变量</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    Class c&#x3D;Class.forName(&quot;cn.net.A&quot;);</span><br><span class="line">    Constructor con&#x3D;c.getConstructor();</span><br><span class="line">    Object obj&#x3D;con.newInstance();</span><br><span class="line">    Field p1Field&#x3D;c.getField(&quot;p1&quot;);</span><br><span class="line">    p1Field.set(obj,3);</span><br><span class="line">    &#x2F;&#x2F;private attribute</span><br><span class="line">    Class c&#x3D;Class.forName(&quot;cn.net.A&quot;);</span><br><span class="line">    Constructor con&#x3D;c.getConstructor();</span><br><span class="line">    Object obj&#x3D;con.newInstance();</span><br><span class="line">    Field p1Field&#x3D;c.getDeclaredField(&quot;p1&quot;);</span><br><span class="line">    p1field.setAccessible(true);</span><br><span class="line">    p1Field.set(obj,3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过反射获取成员方法  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Class c&#x3D;Class.forName(&quot;com.itranswarp.learnjava.Student&quot;);</span><br><span class="line">        Constructor cons&#x3D;c.getConstructor();</span><br><span class="line">        Object obj&#x3D;cons.newInstance();</span><br><span class="line">        Method m1&#x3D;c.getMethod(&quot;add&quot;,int.class,int.class);</span><br><span class="line">        Object a&#x3D;m1.invoke(obj,2,3);</span><br><span class="line">        int b&#x3D;(int) a;</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过反射越过泛型检查  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; array&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        Class c&#x3D;array.getClass();</span><br><span class="line">        Method m&#x3D;c.getMethod(&quot;add&quot;,Object.class);</span><br><span class="line">        m.invoke(array,&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>core learning</tag>
      </tags>
  </entry>
  <entry>
    <title>160. Intersection of Two Linked Lists</title>
    <url>/2021/01/28/getIntersectionNode/</url>
    <content><![CDATA[<ul>
<li>Loop through two lists to get their length of them  </li>
<li>If the tail node of the two lists are different, return null</li>
<li>Skip the longer list ahead X nodes, where X = abs(lenA-lenB).   </li>
<li>Use two pointers until they meet.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span><br><span class="line">       if(headA&#x3D;&#x3D;null||headB&#x3D;&#x3D;null) return null;</span><br><span class="line">       int lena&#x3D;0;</span><br><span class="line">       int lenb&#x3D;0;</span><br><span class="line">       ListNode curA&#x3D;headA;</span><br><span class="line">       ListNode curB&#x3D;headB;</span><br><span class="line">       while(curA.next!&#x3D;null)&#123;</span><br><span class="line">           lena++;</span><br><span class="line">           curA&#x3D;curA.next;</span><br><span class="line">       &#125;</span><br><span class="line">       while(curB.next!&#x3D;null)&#123;</span><br><span class="line">           lenb++;</span><br><span class="line">           curB&#x3D;curB.next;</span><br><span class="line">       &#125;</span><br><span class="line">       if(curA!&#x3D;curB) return null;</span><br><span class="line">       if(lena&gt;lenb)&#123;</span><br><span class="line">           headA&#x3D;skip(headA,lena-lenb);</span><br><span class="line">       &#125;</span><br><span class="line">       else&#123;</span><br><span class="line">           headB&#x3D;skip(headB,lenb-lena);</span><br><span class="line">       &#125;</span><br><span class="line">       while(headA!&#x3D;headB)&#123;</span><br><span class="line">           headA&#x3D;headA.next;</span><br><span class="line">           headB&#x3D;headB.next;</span><br><span class="line">       &#125;</span><br><span class="line">       return headA;</span><br><span class="line">   &#125;</span><br><span class="line">   private ListNode skip(ListNode head,int n)&#123;</span><br><span class="line">       while(n&gt;0)&#123;</span><br><span class="line">           head&#x3D;head.next;</span><br><span class="line">           n--;</span><br><span class="line">       &#125;</span><br><span class="line">       return head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>70. climbing stairs</title>
    <url>/2021/01/28/climbing-stairs/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    &#x2F;&#x2F; HashMap&lt;Integer,Integer&gt; hm&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; public int climbStairs(int n) &#123;</span><br><span class="line">    &#x2F;&#x2F;     if(hm.containsKey(n)) return hm.get(n);</span><br><span class="line">    &#x2F;&#x2F;     if(n&lt;0) return 0;</span><br><span class="line">    &#x2F;&#x2F;     if(n&#x3D;&#x3D;0) return 1;</span><br><span class="line">    &#x2F;&#x2F;     int times&#x3D;climbStairs(n-1)+climbStairs(n-2);</span><br><span class="line">    &#x2F;&#x2F;     hm.put(n,times);</span><br><span class="line">    &#x2F;&#x2F;     return times;</span><br><span class="line">    &#x2F;&#x2F; &#125;</span><br><span class="line">    public int climbStairs(int n)&#123;</span><br><span class="line">        if(n&#x3D;&#x3D;1) return 1;</span><br><span class="line">        int[] dp&#x3D;new int[n+1];</span><br><span class="line">        dp[1]&#x3D;1;</span><br><span class="line">        dp[2]&#x3D;2;</span><br><span class="line">        for(int i&#x3D;3;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            dp[i]&#x3D;dp[i-1]+dp[i-2];</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>21. merge sorted list</title>
    <url>/2021/01/28/merge-sorted-list/</url>
    <content><![CDATA[<p>My initial solution is this:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        if(l1&#x3D;&#x3D;null) return l2;</span><br><span class="line">        if(l2&#x3D;&#x3D;null) return l1;</span><br><span class="line">        if(l1.val&lt;l2.val) return mergeTwoLists(l2,l1);</span><br><span class="line">        ListNode head&#x3D;new ListNode(l2.val);</span><br><span class="line">        head.next&#x3D;mergeTwoLists(l1,l2.next);</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>But notice that you don’t need to create extra space for ListNodes.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        if(l1&#x3D;&#x3D;null) return l2;</span><br><span class="line">        if(l2&#x3D;&#x3D;null) return l1;</span><br><span class="line">        if(l1.val&lt;l2.val) return mergeTwoLists(l2,l1);</span><br><span class="line">        l2.next&#x3D;mergeTwoLists(l1,l2.next);</span><br><span class="line">        return l2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Another way is to do it in iteration.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        ListNode dummy&#x3D;new ListNode();</span><br><span class="line">        ListNode prev&#x3D;dummy;</span><br><span class="line">        while(l1!&#x3D;null&amp;&amp;l2!&#x3D;null)&#123;</span><br><span class="line">            if(l1.val&gt;l2.val)&#123;</span><br><span class="line">                prev.next&#x3D;l2;</span><br><span class="line">                l2&#x3D;l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                prev.next&#x3D;l1;</span><br><span class="line">                l1&#x3D;l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev&#x3D;prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev.next&#x3D;l1&#x3D;&#x3D;null?l2:l1;</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>155 min stack</title>
    <url>/2021/01/28/min-stack/</url>
    <content><![CDATA[<p>Creating two stacks, one to store all the current data, one to store the information of minimum number.  In the min stack, each node stores an int array with size two(the first to store the min number itself, the second to store the number of times it appears)   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;int[]&gt; min&#x3D;new Stack&lt;&gt;();</span><br><span class="line">    &#x2F;** initialize your data structure here. *&#x2F;</span><br><span class="line">    public MinStack() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        if(min.isEmpty()) &#123;</span><br><span class="line">            min.push(new int[]&#123;x,1&#125;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int premin&#x3D;min.peek()[0];</span><br><span class="line">        if(x&#x3D;&#x3D;premin) min.peek()[1]++;</span><br><span class="line">        else if(x&lt;premin)&#123;</span><br><span class="line">            min.push(new int[]&#123;x,1&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void pop() &#123;</span><br><span class="line">        int p&#x3D;stack.pop();</span><br><span class="line">        if(p&#x3D;&#x3D;min.peek()[0])&#123;</span><br><span class="line">            if(min.peek()[1]&#x3D;&#x3D;1) min.pop();</span><br><span class="line">            else&#123;</span><br><span class="line">                min.peek()[1]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">        return stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getMin() &#123;</span><br><span class="line">        return min.peek()[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>two sum</title>
    <url>/2021/01/28/two-sum/</url>
    <content><![CDATA[<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>First of all I think about two-pass HashMap solution, and I made a mistake by not excluding the situation when target-nums[i]=nums[i].<br>But there is one-pass solution where you can do this in O(N) time(faster than O(2N)).</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hm&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">        for(int i&#x3D;0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            int complement&#x3D;target-nums[i];</span><br><span class="line">            if(hm.containsKey(complement))&#123;</span><br><span class="line">                return new int[]&#123;hm.get(complement),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hm.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(&quot;No two sum solution&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>20. valid parenthesis</title>
    <url>/2021/01/28/valid-parenthesis/</url>
    <content><![CDATA[<p>This is my initial solution:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isValid(String s) &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">        for(char c:s.toCharArray())&#123;</span><br><span class="line">            if(c&#x3D;&#x3D;&#39;(&#39;||c&#x3D;&#x3D;&#39;&#123;&#39;||c&#x3D;&#x3D;&#39;[&#39;)&#123;</span><br><span class="line">                stack.add(c);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(stack.isEmpty()) return false;</span><br><span class="line">                char c2&#x3D;stack.pop();</span><br><span class="line">                boolean match&#x3D;false;</span><br><span class="line">                switch(c2)&#123;</span><br><span class="line">                    case &#39;(&#39;:</span><br><span class="line">                        match&#x3D;c&#x3D;&#x3D;&#39;)&#39;;</span><br><span class="line">                        break;</span><br><span class="line">                    case &#39;&#123;&#39;:</span><br><span class="line">                        match&#x3D;c&#x3D;&#x3D;&#39;&#125;&#39;;</span><br><span class="line">                        break;</span><br><span class="line">                    case &#39;[&#39;:</span><br><span class="line">                        match&#x3D;c&#x3D;&#x3D;&#39;]&#39;;</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(!match) return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>But it can be improved by creating a hashmap to establish the mapping relation between the open brackets and closed brackets.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isValid(String s) &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character,Character&gt; mapping&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">        mapping.put(&#39;)&#39;,&#39;(&#39;);</span><br><span class="line">        mapping.put(&#39;]&#39;,&#39;[&#39;);</span><br><span class="line">        mapping.put(&#39;&#125;&#39;,&#39;&#123;&#39;);</span><br><span class="line">        for(char c:s.toCharArray())&#123;</span><br><span class="line">            if(mapping.containsKey(c))&#123;</span><br><span class="line">                char match&#x3D;stack.isEmpty()?&#39;#&#39;:stack.pop();</span><br><span class="line">                if(match!&#x3D;mapping.get(c)) return false;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>majorityElement</title>
    <url>/2021/01/28/majorityElement/</url>
    <content><![CDATA[<ul>
<li>Keep a variable ‘majority’ and keep a variable ‘count’.</li>
<li>Loop through the array, if current number is not equal to majority, minus the count by one and if count equals zero, replace the majority with current number  </li>
<li>If current number equals majority, increment count by 1.</li>
<li>The idea behind this is that the majority element is guaranteed to be more than N/2, so the count of it will always be larger than 0 no matter how many it is offseted by other element.  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int majorityElement(int[] nums) &#123;</span><br><span class="line">        int majority&#x3D;nums[0];</span><br><span class="line">        int count&#x3D;1;</span><br><span class="line">        for(int i&#x3D;1;i&lt;nums.length;i++)&#123;</span><br><span class="line">            if(majority&#x3D;&#x3D;nums[i]) count++;</span><br><span class="line">            else&#123;</span><br><span class="line">                count--;</span><br><span class="line">                if(count&#x3D;&#x3D;0)&#123;</span><br><span class="line">                    majority&#x3D;nums[i];</span><br><span class="line">                    count&#x3D;1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return majority;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>reverse_list</title>
    <url>/2021/01/28/reverse-list/</url>
    <content><![CDATA[<h3 id="206"><a href="#206" class="headerlink" title="206"></a>206</h3><ul>
<li>recursive<br><img src="/images/post_images/linked1.png" alt="diagram1">  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        if(head&#x3D;&#x3D;null||head.next&#x3D;&#x3D;null) return head;</span><br><span class="line">        ListNode last&#x3D;reverseList(head.next);</span><br><span class="line">        head.next.next&#x3D;head;</span><br><span class="line">        head.next&#x3D;null;</span><br><span class="line">        return last;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<ul>
<li>iterative<br>keep three handles–pre,cur,nxt  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        ListNode pre&#x3D;null,cur&#x3D;head,nxt&#x3D;head;</span><br><span class="line">        while(cur!&#x3D;null)&#123;</span><br><span class="line">            nxt&#x3D;cur.next;</span><br><span class="line">            cur.next&#x3D;pre;</span><br><span class="line">            pre&#x3D;cur;</span><br><span class="line">            cur&#x3D;nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>15. 3Sum</title>
    <url>/2021/01/29/3sum/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);&#x2F;&#x2F;Using two pointers technique, you must sort the array first</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">            for(int i&#x3D;0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            if(nums[i]&gt;0) break;</span><br><span class="line">            if(i!&#x3D;0&amp;&amp;nums[i]&#x3D;&#x3D;nums[i-1]) continue;</span><br><span class="line">            int lo&#x3D;i+1;</span><br><span class="line">            int hi&#x3D;nums.length-1;</span><br><span class="line">            while(lo&lt;hi)&#123;</span><br><span class="line">                int sum&#x3D;nums[lo]+nums[hi]+nums[i];</span><br><span class="line">                if(sum&gt;0)&#123;</span><br><span class="line">                    hi--;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(sum&lt;0)&#123;</span><br><span class="line">                    lo++;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[i],nums[lo++],nums[hi--]));</span><br><span class="line">                     while(lo&lt;hi&amp;&amp;nums[lo]&#x3D;&#x3D;nums[lo-1])&#123;</span><br><span class="line">                    lo++;&#x2F;&#x2F; You can only move lo to avoid repetitive elements until you can make sure that it is not the first element of scanning</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>2. Add Two Numbers</title>
    <url>/2021/01/29/addTwoNumbers/</url>
    <content><![CDATA[<p>My initial code:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        int add&#x3D;0;</span><br><span class="line">        ListNode head&#x3D;new ListNode();</span><br><span class="line">        ListNode cur&#x3D;head;</span><br><span class="line">        while(l1!&#x3D;null&amp;&amp;l2!&#x3D;null)&#123;</span><br><span class="line">            cur.val&#x3D;((l1.val+l2.val+add)%10);</span><br><span class="line">            add&#x3D;(l1.val+l2.val+add)&#x2F;10;</span><br><span class="line">            l1&#x3D;l1.next;</span><br><span class="line">            l2&#x3D;l2.next;</span><br><span class="line">            if(l1&#x3D;&#x3D;null&amp;&amp;l2&#x3D;&#x3D;null&amp;&amp;add&#x3D;&#x3D;0) break;</span><br><span class="line">            cur.next&#x3D;new ListNode();</span><br><span class="line">            cur&#x3D;cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l1&#x3D;&#x3D;null)&#123;</span><br><span class="line">            l1&#x3D;l2;</span><br><span class="line">        &#125;</span><br><span class="line">        while(l1!&#x3D;null)&#123;</span><br><span class="line">            cur.val&#x3D;((l1.val+add)%10);</span><br><span class="line">            add&#x3D;(l1.val+add)&#x2F;10;</span><br><span class="line">            l1&#x3D;l1.next;</span><br><span class="line">            if(l1&#x3D;&#x3D;null&amp;&amp;add&#x3D;&#x3D;0) break;</span><br><span class="line">            cur.next&#x3D;new ListNode();</span><br><span class="line">            cur&#x3D;cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(add!&#x3D;0)&#123;</span><br><span class="line">            cur.val&#x3D;add;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>But it is really redundant:  </p>
<ul>
<li>A dummyhead can be created to be followed by the actual head node  </li>
<li>Merge the two blocks together  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">        int add&#x3D;0;</span><br><span class="line">        ListNode dummyHead&#x3D;new ListNode();</span><br><span class="line">        ListNode cur&#x3D;dummyHead;</span><br><span class="line">        while(l1!&#x3D;null||l2!&#x3D;null)&#123;</span><br><span class="line">            int x&#x3D;l1&#x3D;&#x3D;null?0:l1.val;</span><br><span class="line">            int y&#x3D;l2&#x3D;&#x3D;null?0:l2.val;</span><br><span class="line">            int sum&#x3D;x+y+add;</span><br><span class="line">            add&#x3D;sum&#x2F;10;</span><br><span class="line">            cur.next&#x3D;new ListNode(sum%10);</span><br><span class="line">            cur&#x3D;cur.next;</span><br><span class="line">            if(l1!&#x3D;null) l1&#x3D;l1.next;</span><br><span class="line">            if(l2!&#x3D;null) l2&#x3D;l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(add!&#x3D;0)&#123;</span><br><span class="line">            cur.next&#x3D;new ListNode(add);</span><br><span class="line">        &#125;</span><br><span class="line">        return dummyHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>Binary Search</title>
    <url>/2021/01/30/binary-search/</url>
    <content><![CDATA[<h2 id="Three-templates-of-binary-search"><a href="#Three-templates-of-binary-search" class="headerlink" title="Three templates of binary search"></a>Three templates of binary search</h2><h3 id="basic-template"><a href="#basic-template" class="headerlink" title="basic template"></a>basic template</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int binarySearch(int[] nums, int target) &#123;</span><br><span class="line">    int left &#x3D; 0; </span><br><span class="line">    int right &#x3D; nums.length - 1; &#x2F;&#x2F; attention</span><br><span class="line">    while(left &lt;&#x3D; right) &#123; &#x2F;&#x2F; attention</span><br><span class="line">        int mid &#x3D; (right + left) &#x2F; 2;</span><br><span class="line">        if(nums[mid] &#x3D;&#x3D; target)</span><br><span class="line">            return mid; </span><br><span class="line">        else if (nums[mid] &lt; target)</span><br><span class="line">            left &#x3D; mid + 1; &#x2F;&#x2F; attention</span><br><span class="line">        else if (nums[mid] &gt; target)</span><br><span class="line">            right &#x3D; mid - 1; &#x2F;&#x2F; attention</span><br><span class="line">        &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The interval used in this algorithm is [left,right], so the ending condition is left&gt;right.</p>
<a id="more"></a>

<h3 id="finding-the-left-bound"><a href="#finding-the-left-bound" class="headerlink" title="finding the left bound"></a>finding the left bound</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int left_bound(int[] nums, int target) &#123;</span><br><span class="line">if (nums.length &#x3D;&#x3D; 0) return -1;</span><br><span class="line">int left &#x3D; 0;</span><br><span class="line">int right &#x3D; nums.length; &#x2F;&#x2F; attention</span><br><span class="line">while (left &lt; right) &#123; &#x2F;&#x2F; attention</span><br><span class="line">    int mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">    if (nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">       right &#x3D; mid;</span><br><span class="line">       &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">            left &#x3D; mid + 1;</span><br><span class="line">       &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">            right &#x3D; mid; &#x2F;&#x2F; attention</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return (left!&#x3D;nums.length&amp;&amp;nums[left]&#x3D;&#x3D;target)?left:-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>The interval used in this algorithm is [left,right), so the ending condition is left==right.  </li>
<li>Keep in mind one property of this algorithm, if target does not exist in the nums array, left will always end at the element that is the first which is larger than target in the array.  </li>
</ul>
<h3 id="finding-the-right-bound"><a href="#finding-the-right-bound" class="headerlink" title="finding the right bound"></a>finding the right bound</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int right_bound(int[] nums, int target) &#123;</span><br><span class="line">  if (nums.length &#x3D;&#x3D; 0) return -1;</span><br><span class="line">  int left &#x3D; 0, right &#x3D; nums.length;</span><br><span class="line"></span><br><span class="line">  while (left &lt; right) &#123;</span><br><span class="line">      int mid &#x3D; (left + right) &#x2F; 2;</span><br><span class="line">      if (nums[mid] &#x3D;&#x3D; target) &#123;</span><br><span class="line">          left &#x3D; mid + 1; &#x2F;&#x2F;this is the reason that it should return left-1</span><br><span class="line">      &#125; else if (nums[mid] &lt; target) &#123;</span><br><span class="line">          left &#x3D; mid + 1;</span><br><span class="line">      &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">          right &#x3D; mid;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return (left!&#x3D;0&amp;&amp;nums[left-1]&#x3D;&#x3D;target)?left-1:-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>problem solving template</tag>
        <tag>leetcode</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>19. Remove Nth Node From End of List</title>
    <url>/2021/01/29/removeNthFromEnd/</url>
    <content><![CDATA[<p>Again using a dummy head is crucial for solving this problem.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">        ListNode dummyHead&#x3D;new ListNode(0,head);</span><br><span class="line">        ListNode right&#x3D;head;</span><br><span class="line">        for(int i&#x3D;n;i&gt;0;i--)&#123;</span><br><span class="line">            right&#x3D;right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur&#x3D;head;</span><br><span class="line">        ListNode pre&#x3D;dummyHead;</span><br><span class="line">        while(right!&#x3D;null)&#123;</span><br><span class="line">            cur&#x3D;cur.next;</span><br><span class="line">            pre&#x3D;pre.next;</span><br><span class="line">            right&#x3D;right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next&#x3D;cur.next;</span><br><span class="line">        return dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>17. Letter Combinations of a Phone Number</title>
    <url>/2021/01/29/letterCombinations/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;String&gt; res&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">    HashMap&lt;Integer,char[]&gt; digitToLetter&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">    public List&lt;String&gt; letterCombinations(String digits) &#123;</span><br><span class="line">        if(digits&#x3D;&#x3D;null||digits.length()&#x3D;&#x3D;0) return res;</span><br><span class="line">        digitToLetter.put(2,new char[]&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;);</span><br><span class="line">        digitToLetter.put(3,new char[]&#123;&#39;d&#39;,&#39;e&#39;,&#39;f&#39;&#125;);</span><br><span class="line">        digitToLetter.put(4,new char[]&#123;&#39;g&#39;,&#39;h&#39;,&#39;i&#39;&#125;);</span><br><span class="line">        digitToLetter.put(5,new char[]&#123;&#39;j&#39;,&#39;k&#39;,&#39;l&#39;&#125;);</span><br><span class="line">        digitToLetter.put(6,new char[]&#123;&#39;m&#39;,&#39;n&#39;,&#39;o&#39;&#125;);</span><br><span class="line">        digitToLetter.put(7,new char[]&#123;&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;&#125;);</span><br><span class="line">        digitToLetter.put(8,new char[]&#123;&#39;t&#39;,&#39;u&#39;,&#39;v&#39;&#125;);</span><br><span class="line">        digitToLetter.put(9,new char[]&#123;&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;&#125;);</span><br><span class="line">        StringBuilder track&#x3D;new StringBuilder();</span><br><span class="line">        backtrack(track,digits,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    private void backtrack(StringBuilder track,String digits,int index)&#123;</span><br><span class="line">        if(index&#x3D;&#x3D;digits.length())&#123;</span><br><span class="line">            res.add(track.toString());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(char c:digitToLetter.get(digits.charAt(index)-&#39;0&#39;))&#123;</span><br><span class="line">            track.append(c);</span><br><span class="line">            backtrack(track,digits,index+1);</span><br><span class="line">            track.deleteCharAt(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>33. Search in Rotated Sorted Array</title>
    <url>/2021/01/29/search-rotated/</url>
    <content><![CDATA[<p>Formula: If a sorted array is shifted, if you take the middle, always one side will be sorted. Take the recursion according to that rule.</p>
<ul>
<li>take the middle and compare with target, if matches return.</li>
<li>if middle is bigger than left side, it means left is sorted<ul>
<li>if [left] &lt; target &lt; [middle] then do recursion with left, middle - 1 (right)</li>
<li>left side is sorted, but target not in here, search on right side middle + 1 (left), right</li>
</ul>
</li>
<li>if middle is less than right side, it means right is sorted<ul>
<li>if [middle] &lt; target &lt; [right] then do recursion with middle + 1 (left), right</li>
<li>right side is sorted, but target not in here, search on left side left, middle -1 (right)  </li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">        int left&#x3D;0;</span><br><span class="line">        int right&#x3D;nums.length-1;</span><br><span class="line">        while(left&lt;&#x3D;right)&#123;</span><br><span class="line">            int mid&#x3D;(left+right)&#x2F;2;</span><br><span class="line">            if(nums[mid]&#x3D;&#x3D;target) return mid;</span><br><span class="line">            if(nums[mid]&gt;&#x3D;nums[left])&#123;&#x2F;&#x2F;NOTICE!!!!!The equal mark is extremly important here!Considering this case: nums&#x3D;&#123;3,1&#125;, target&#x3D;1, you will want both 3 and 1 to be examined. And you can only do this by adding an equal mark here.</span><br><span class="line">                if(target&lt;nums[mid]&amp;&amp;target&gt;&#x3D;nums[left])&#123;</span><br><span class="line">                    right&#x3D;mid-1;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    left&#x3D;mid+1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(target&gt;nums[mid]&amp;&amp;target&lt;&#x3D;nums[right])&#123;</span><br><span class="line">                    left&#x3D;mid+1;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    right&#x3D;mid-1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>39. Combination Sum</title>
    <url>/2021/01/30/combinationSum/</url>
    <content><![CDATA[<pre><code>class Solution &#123;
    List&lt;List&lt;Integer&gt;&gt; res=new LinkedList&lt;&gt;();
    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;
        List&lt;Integer&gt; track=new ArrayList&lt;&gt;();
        backtrack(track,candidates,target,0);
        return res;
    &#125;
    private void backtrack(List&lt;Integer&gt; track,int[] candidates, int target,int start)&#123;
        if(target&lt;0) return;
        if(target==0)&#123;
            res.add(new ArrayList&lt;Integer&gt;(track));
            return;
        &#125;
        for(int i=start;i&lt;candidates.length;i++)&#123;
            track.add(candidates[i]);
            backtrack(track,candidates,target-candidates[i],i);
            track.remove(track.size()-1);
        &#125;
    &#125;
&#125;</code></pre>
<p>Notice that the parameter start is very crucial here, which guarantees that we won’t get repetitive answer by avoiding adding the element with which all the possible combinations have been added to the result.</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>Jump Game</title>
    <url>/2021/01/30/canJump/</url>
    <content><![CDATA[<h3 id="55"><a href="#55" class="headerlink" title="55"></a>55</h3><p>For each step,update the farthest place you can go, if you cannot go any farther, return false.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canJump(int[] nums) &#123;</span><br><span class="line">        int farthest&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;nums.length-1;i++)&#123;</span><br><span class="line">            farthest&#x3D;Math.max(farthest,i+nums[i]);</span><br><span class="line">            if(farthest&#x3D;&#x3D;i) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="45"><a href="#45" class="headerlink" title="45"></a>45</h3><ul>
<li>First solution is to use dynamic programming(However it exceeds time limit)  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int jump(int[] nums) &#123;</span><br><span class="line">        int n&#x3D;nums.length;</span><br><span class="line">        int[] dp&#x3D;new int[n];</span><br><span class="line">        Arrays.fill(dp,n);</span><br><span class="line">        dp[n-1]&#x3D;0;</span><br><span class="line">        for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">            for(int x&#x3D;0;x&lt;&#x3D;nums[i];x++)&#123;</span><br><span class="line">                if(i+x&gt;n-1) break;</span><br><span class="line">                dp[i]&#x3D;Math.min(dp[i],dp[i+x]+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Second solution will use greedy.  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int jump(int[] nums) &#123;</span><br><span class="line">        int end&#x3D;0;</span><br><span class="line">        int farthest&#x3D;0;</span><br><span class="line">        int jumps&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;nums.length-1;i++)&#123;&#x2F;&#x2F;Notice that the iteration stops at the last but one element because there will be no jumps update at the end</span><br><span class="line">            farthest&#x3D;Math.max(farthest,nums[i]+i);</span><br><span class="line">            if(end&#x3D;&#x3D;i)&#123;</span><br><span class="line">                jumps++;</span><br><span class="line">                end&#x3D;farthest;&#x2F;&#x2F;end will always be inside the jumpable area of the step that we actually take so we can update jumps after we take that step here</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return jumps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The core idea here is to pick up the element that has the most potential.<br><img src="/images/post_images/jump_diagram1.png"><br>As this picture shows, the next step we will jump to is index 2, because its jumpable area covers[3,6] which is larger than others.  </p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>49. Group Anagrams</title>
    <url>/2021/01/30/groupAnagrams/</url>
    <content><![CDATA[<ul>
<li>The most important idea of this question is to use a hashmap to store all the lists of same anagrams.  </li>
<li>There are two possible keys:  <ul>
<li>the sorted string</li>
<li>character counts(eg. The character count of ‘ab’ can be ‘1#1#0…#0’)<a id="more"></a>

</li>
</ul>
</li>
</ul>
<p>Here is the code for the second solution:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        HashMap&lt;String,List&gt; mapping&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">        for(String s:strs)&#123;</span><br><span class="line">            int[] count&#x3D;new int[26];</span><br><span class="line">            for(char c:s.toCharArray())&#123;</span><br><span class="line">                count[c-&#39;a&#39;]++;</span><br><span class="line">            &#125;</span><br><span class="line">            StringBuilder sb&#x3D;new StringBuilder();</span><br><span class="line">            for(int i:count)&#123;</span><br><span class="line">                sb.append(i);</span><br><span class="line">                sb.append(&quot;#&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            String index&#x3D;sb.toString();</span><br><span class="line">            if(!mapping.containsKey(index))&#123;</span><br><span class="line">                mapping.put(index,new ArrayList&lt;String&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            mapping.get(index).add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        return new ArrayList(mapping.values());&#x2F;&#x2F;The values method of hashmap will return a collection, and arraylist has a constructor that can take a collection. </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>merge56</title>
    <url>/2021/01/30/merge56/</url>
    <content><![CDATA[<p>The core of this question is to sort the array by the first element of each subarray.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] merge(int[][] intervals) &#123;</span><br><span class="line">        Arrays.sort(intervals,new Comparator&lt;int[]&gt;()&#123;</span><br><span class="line">            public int compare(int[] a,int[] b)&#123;</span><br><span class="line">                return a[0]-b[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        LinkedList&lt;int[]&gt; merged&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        for(int[] interval:intervals)&#123;</span><br><span class="line">            if(merged.isEmpty()||merged.getLast()[1]&lt;interval[0])&#123;</span><br><span class="line">                merged.add(interval);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                if(merged.getLast()[1]&lt;interval[1])&#123;</span><br><span class="line">                    merged.getLast()[1]&#x3D;interval[1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return merged.toArray(new int[merged.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>64. Minimum Path Sum</title>
    <url>/2021/01/30/minPathSum/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minPathSum(int[][] grid) &#123;</span><br><span class="line">        int m&#x3D;grid.length;</span><br><span class="line">        int n&#x3D;grid[0].length;</span><br><span class="line">        int[] dp&#x3D;new int[n];</span><br><span class="line">        dp[0]&#x3D;grid[0][0];</span><br><span class="line">        &#x2F;&#x2F; for(int i&#x3D;1;i&lt;m;i++)&#123;</span><br><span class="line">        &#x2F;&#x2F;     dp[i][0]&#x3D;dp[i-1][0]+grid[i][0];</span><br><span class="line">        &#x2F;&#x2F; &#125;</span><br><span class="line">        for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i]&#x3D;dp[i-1]+grid[0][i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;1;i&lt;m;i++)&#123;</span><br><span class="line">            dp[0]+&#x3D;grid[i][0];</span><br><span class="line">            for(int j&#x3D;1;j&lt;n;j++)&#123;</span><br><span class="line">                dp[j]&#x3D;Math.min(dp[j],dp[j-1])+grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>48. Rotate Image</title>
    <url>/2021/01/30/rotate/</url>
    <content><![CDATA[<p><strong>Every rotation is the product of two reflections.</strong>  </p>
<ul>
<li>For the requirement of this question, we first reverse the matrix around the main diagonal, and then reverse it from left to right. </li>
<li>It is called transpose and reflect in linear algebra.  </li>
<li>If you change the mirror function from top to bottom and change the order of transpose and mirror, you can get the other three angles.  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void rotate(int[][] matrix) &#123;</span><br><span class="line">        transpose(matrix);</span><br><span class="line">        mirror(matrix);</span><br><span class="line">    &#125;</span><br><span class="line">    private void transpose(int[][] matrix)&#123;</span><br><span class="line">        for(int i&#x3D;1;i&lt;matrix.length;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;i;j++)&#123;</span><br><span class="line">                int temp&#x3D;matrix[i][j];</span><br><span class="line">                matrix[i][j]&#x3D;matrix[j][i];</span><br><span class="line">                matrix[j][i]&#x3D;temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void mirror(int[][] matrix)&#123;</span><br><span class="line">        int n&#x3D;matrix.length;</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;n&#x2F;2;j++)&#123;</span><br><span class="line">                int temp&#x3D;matrix[i][j];</span><br><span class="line">                matrix[i][j]&#x3D;matrix[i][n-j-1];</span><br><span class="line">                matrix[i][n-j-1]&#x3D;temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>sortColors</title>
    <url>/2021/01/30/sortColors/</url>
    <content><![CDATA[<ul>
<li><p>We will use three pointers here to track the rightmost boundary of zeros, the leftmost boundary of twos and the current element under the consideration.  </p>
</li>
<li><p>While curr &lt;= p2 :</p>
<ul>
<li><p>If nums[curr] = 0 : swap currth and p0th elements and move both pointers to the right.</p>
</li>
<li><p>If nums[curr] = 2 : swap currth and p2th elements. Move pointer p2 to the left.</p>
</li>
<li><p>If nums[curr] = 1 : move pointer curr to the right.  </p>
<a id="more"></a>

</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void sortColors(int[] nums) &#123;</span><br><span class="line">        int n&#x3D;nums.length-1;</span><br><span class="line">        int cur&#x3D;0,left&#x3D;0,right&#x3D;n;</span><br><span class="line">        while(cur&lt;&#x3D;right)&#123;</span><br><span class="line">            if(nums[cur]&#x3D;&#x3D;0)&#123;</span><br><span class="line">                swap(nums,cur,left);</span><br><span class="line">                left++;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(nums[cur]&#x3D;&#x3D;2)&#123;</span><br><span class="line">                swap(nums,cur,right);</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void swap(int[] nums,int l,int r)&#123;</span><br><span class="line">        int temp&#x3D;nums[l];</span><br><span class="line">        nums[l]&#x3D;nums[r];</span><br><span class="line">        nums[r]&#x3D;temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>subsets</title>
    <url>/2021/01/30/subsets/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;</span><br><span class="line">        backtrack(new ArrayList&lt;Integer&gt;(),nums,0);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    private void backtrack(ArrayList&lt;Integer&gt; track,int[] nums,int start)&#123;</span><br><span class="line">        res.add(new ArrayList&lt;Integer&gt;(track));</span><br><span class="line">        for(int i&#x3D;start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            backtrack(track,nums,i+1);</span><br><span class="line">            track.remove(track.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>62. Unique Paths</title>
    <url>/2021/01/30/uniquePaths/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePaths(int m, int n) &#123;</span><br><span class="line">        if(n&gt;m) return uniquePaths(n,m);</span><br><span class="line">        int[] dp&#x3D;new int[n];</span><br><span class="line">        dp[0]&#x3D;1;</span><br><span class="line">        for(int i&#x3D;1;i&lt;m;i++)&#123;</span><br><span class="line">            dp[0]&#x3D;1;</span><br><span class="line">            for(int j&#x3D;1;j&lt;n;j++)&#123;</span><br><span class="line">                if(i&#x3D;&#x3D;1) dp[j]&#x3D;dp[j-1]+1;</span><br><span class="line">                else dp[j]&#x3D;dp[j-1]+dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>105. Construct Binary Tree from Preorder and Inorder Traversal</title>
    <url>/2021/02/01/buildTree105/</url>
    <content><![CDATA[<p>The main idea is illustrated in the diagram below:<br><img src="/images/post_images/105_diagram.png">  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        if(preorder&#x3D;&#x3D;null||preorder.length&#x3D;&#x3D;0) return null;</span><br><span class="line">        return buildTree(preorder,0,preorder.length-1,inorder,0,preorder.length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    private TreeNode buildTree(int[] preorder,int pre_s,int pre_e,</span><br><span class="line">                               int[] inorder,int in_s,int in_e)&#123;</span><br><span class="line">        if(pre_s&gt;pre_e) return null;</span><br><span class="line">        TreeNode root&#x3D;new TreeNode(preorder[pre_s]);</span><br><span class="line">        int root_pos&#x3D;0;</span><br><span class="line">        for(int i&#x3D;in_s;i&lt;&#x3D;in_e;i++)&#123;</span><br><span class="line">            if(inorder[i]&#x3D;&#x3D;preorder[pre_s])&#123;</span><br><span class="line">                root_pos&#x3D;i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int left_size&#x3D;root_pos-in_s;</span><br><span class="line">        root.left&#x3D;buildTree(preorder,pre_s+1,pre_s+left_size,</span><br><span class="line">                           inorder,in_s,root_pos-1);</span><br><span class="line">        root.right&#x3D;buildTree(preorder,pre_s+left_size+1,pre_e,</span><br><span class="line">                           inorder,root_pos+1,in_e);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title>98. Validate Binary Search Tree</title>
    <url>/2021/02/01/isValidBST/</url>
    <content><![CDATA[<h3 id="method-1-preorder"><a href="#method-1-preorder" class="headerlink" title="method 1(preorder)"></a>method 1(preorder)</h3><p>Valid BST must fulfill max.val &gt; root.val &gt; min.val<br>expand the parameter list to pass the min and max on  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean validate(TreeNode root, Integer low, Integer high) &#123;</span><br><span class="line">        &#x2F;&#x2F; Empty trees are valid BSTs.</span><br><span class="line">        if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; The current node&#39;s value must be between low and high.</span><br><span class="line">        if ((low !&#x3D; null &amp;&amp; root.val &lt;&#x3D; low) || (high !&#x3D; null &amp;&amp; root.val &gt;&#x3D; high)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; The left and right subtree must also be valid.</span><br><span class="line">        return validate(root.right, root.val, high) &amp;&amp; validate(root.left, low, root.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        return validate(root, null, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="method-2-inorder"><a href="#method-2-inorder" class="headerlink" title="method 2(inorder)"></a>method 2(inorder)</h3><p>To keep the previous traversed node in class variable prev, if root.val&lt;=prev, return false.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    Integer prev;</span><br><span class="line">    public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null) return true;</span><br><span class="line">        if(!isValidBST(root.left)) return false;</span><br><span class="line">        if(prev!&#x3D;null&amp;&amp;root.val&lt;&#x3D;prev) return false;</span><br><span class="line">        prev&#x3D;root.val;</span><br><span class="line">        return isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title>levelOrder</title>
    <url>/2021/02/01/levelOrder/</url>
    <content><![CDATA[<p>The two most important variables here is level and level_length.  Length is to keep track of the depth of current iteration(We will also use it to act as the index of returned array). If we finish looping through all the elements in current level, increment level by one and the size of current queue will be level_length, that is, the number of elements in the next level.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        if(root&#x3D;&#x3D;null) return res;</span><br><span class="line">        Queue&lt;TreeNode&gt; q&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        int level&#x3D;0;</span><br><span class="line">        while(!q.isEmpty())&#123;</span><br><span class="line">            res.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">            int level_length&#x3D;q.size();</span><br><span class="line">            for(int i&#x3D;0;i&lt;level_length;i++)&#123;</span><br><span class="line">                TreeNode cur&#x3D;q.poll();</span><br><span class="line">                res.get(level).add(cur.val);</span><br><span class="line">                if(cur.left!&#x3D;null)&#123;</span><br><span class="line">                    q.add(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(cur.right!&#x3D;null)&#123;</span><br><span class="line">                    q.add(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>breadth first search</tag>
      </tags>
  </entry>
  <entry>
    <title>96. Unique Binary Search Trees</title>
    <url>/2021/02/01/numTrees96/</url>
    <content><![CDATA[<p>The main idea of this question can be illustrated by the diagram below.<br><img src="/images/post_images/96_diagram.png">  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numTrees(int n) &#123;</span><br><span class="line">        if(n&#x3D;&#x3D;1) return 1;</span><br><span class="line">        int[] dp&#x3D;new int[n+1];</span><br><span class="line">        dp[0]&#x3D;1;</span><br><span class="line">        dp[1]&#x3D;1;</span><br><span class="line">        for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            for(int j&#x3D;1;j&lt;&#x3D;i;j++)&#123;</span><br><span class="line">                dp[i]+&#x3D;dp[j-1]*dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>138. Copy List with Random Pointer</title>
    <url>/2021/02/01/copyRandomList/</url>
    <content><![CDATA[<ul>
<li>method 1<br>Using hashmap to map old node to new node  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    HashMap&lt;Node,Node&gt; oldToNew&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">    public Node copyRandomList(Node head) &#123;</span><br><span class="line">        Node curo&#x3D;head;</span><br><span class="line">        Node curn&#x3D;getClonedNode(head);</span><br><span class="line">        while(curo!&#x3D;null)&#123;</span><br><span class="line">            curn.next&#x3D;getClonedNode(curo.next);</span><br><span class="line">            curn.random&#x3D;getClonedNode(curo.random);</span><br><span class="line">            curn&#x3D;curn.next;</span><br><span class="line">            curo&#x3D;curo.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return oldToNew.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">    private Node getClonedNode(Node head)&#123;</span><br><span class="line">        if(head&#x3D;&#x3D;null) return null;</span><br><span class="line">        if(oldToNew.containsKey(head)) return oldToNew.get(head);</span><br><span class="line">        Node n&#x3D;new Node(head.val);</span><br><span class="line">        oldToNew.put(head,n);</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<ul>
<li>method 2<br>Instead of using a hashmap, we put new node next to the old node to locate it. At last we need to unweave them.  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public Node copyRandomList(Node head) &#123;</span><br><span class="line">        if(head&#x3D;&#x3D;null) return null;</span><br><span class="line">        Node cur&#x3D;head;</span><br><span class="line">        while(cur!&#x3D;null)&#123;</span><br><span class="line">            Node n&#x3D;new Node(cur.val);</span><br><span class="line">            n.next&#x3D;cur.next;</span><br><span class="line">            cur.next&#x3D;n;</span><br><span class="line">            cur&#x3D;n.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur&#x3D;head;</span><br><span class="line">        while(cur!&#x3D;null)&#123;</span><br><span class="line">            cur.next.random&#x3D;cur.random&#x3D;&#x3D;null?null:cur.random.next;</span><br><span class="line">            cur&#x3D;cur.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur&#x3D;head;</span><br><span class="line">        Node newcur&#x3D;head.next;</span><br><span class="line">        Node newhead&#x3D;head.next;</span><br><span class="line">        while(cur!&#x3D;null)&#123;</span><br><span class="line">            cur.next&#x3D;newcur.next;</span><br><span class="line">            newcur.next&#x3D;newcur.next&#x3D;&#x3D;null?null:newcur.next.next;</span><br><span class="line">            cur&#x3D;cur.next;</span><br><span class="line">            newcur&#x3D;newcur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title>114. Flatten Binary Tree to Linked List</title>
    <url>/2021/02/01/flatten/</url>
    <content><![CDATA[<p>Using postorder traverse, first flatten the left subtree, then flatten the right subtree. Preserve current right node, point the right node of root to its current left node and point the left node to null. Find the last node of right subtree and connect previous right node to its right.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void flatten(TreeNode root) &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null) return;</span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line">        TreeNode right&#x3D;root.right;</span><br><span class="line">        root.right&#x3D;root.left;</span><br><span class="line">        root.left&#x3D;null;</span><br><span class="line">        TreeNode cur&#x3D;root;</span><br><span class="line">        while(cur.right!&#x3D;null)&#123;</span><br><span class="line">            cur&#x3D;cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.right&#x3D;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title>139. Word Break</title>
    <url>/2021/02/01/wordBreak/</url>
    <content><![CDATA[<p>dp[i] means the possiblity of segmenting string[0…i-1]  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;</span><br><span class="line">        Set&lt;String&gt; dict&#x3D;new HashSet&lt;&gt;(wordDict);</span><br><span class="line">        boolean[] dp&#x3D;new boolean[s.length()+1];</span><br><span class="line">        dp[0]&#x3D;true;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;s.length();i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;i;j++)&#123;</span><br><span class="line">                if(dp[j]&amp;&amp;dict.contains(s.substring(j,i)))&#123;</span><br><span class="line">                    dp[i]&#x3D;true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>courseSchedule</title>
    <url>/2021/02/02/courseSchedule/</url>
    <content><![CDATA[<h3 id="207"><a href="#207" class="headerlink" title="207"></a>207</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    boolean[] visited;</span><br><span class="line">    HashSet&lt;Integer&gt; checked&#x3D;new HashSet&lt;&gt;();</span><br><span class="line">    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;</span><br><span class="line">        HashMap&lt;Integer,List&lt;Integer&gt;&gt; pre&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">        for(int[] re:prerequisites)&#123;</span><br><span class="line">            if(!pre.containsKey(re[0]))&#123;</span><br><span class="line">                pre.put(re[0],new LinkedList&lt;Integer&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            pre.get(re[0]).add(re[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        visited&#x3D;new boolean[numCourses];</span><br><span class="line">        for(int i&#x3D;0;i&lt;numCourses;i++)&#123;</span><br><span class="line">            if(isCycle(i,pre)) return false;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean isCycle(int course,HashMap&lt;Integer,List&lt;Integer&gt;&gt; pre)&#123;</span><br><span class="line">        if(checked.contains(course)) return false;</span><br><span class="line">        if(!pre.containsKey(course)) return false;</span><br><span class="line">        if(visited[course]) return true;</span><br><span class="line">        visited[course]&#x3D;true;</span><br><span class="line">        for(int i:pre.get(course))&#123;  </span><br><span class="line">            if(isCycle(i,pre)) return true;</span><br><span class="line">            checked.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        visited[course]&#x3D;false;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Notice that in this problem we don’t need to ‘make the choice’ and ‘revoke the choice’ in looping, because we do not have a track variable to keep.</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>146. LRU Cache</title>
    <url>/2021/02/02/lru/</url>
    <content><![CDATA[<p>LinkedList has order, but its finding is time-consuming. HashMap is quick in finding but its data doesn’t have order. So we need to use linkedhashmap which combines the characteristics of them both.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LRUCache &#123;</span><br><span class="line">    LinkedHashMap&lt;Integer,Integer&gt; keyToVal;</span><br><span class="line">    int cap;</span><br><span class="line">    public LRUCache(int capacity) &#123;</span><br><span class="line">        keyToVal&#x3D;new LinkedHashMap&lt;&gt;();</span><br><span class="line">        cap&#x3D;capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int get(int key) &#123;</span><br><span class="line">        if(!keyToVal.containsKey(key)) return -1;</span><br><span class="line">        return makeRecent(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void put(int key, int value) &#123;</span><br><span class="line">        if(keyToVal.containsKey(key))&#123;</span><br><span class="line">            keyToVal.put(key,value);</span><br><span class="line">            makeRecent(key);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(keyToVal.size()&#x3D;&#x3D;cap)&#123;</span><br><span class="line">            int re&#x3D;keyToVal.keySet().iterator().next();</span><br><span class="line">            keyToVal.remove(re);</span><br><span class="line">        &#125;</span><br><span class="line">        keyToVal.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    private int makeRecent(int key)&#123;</span><br><span class="line">        int val&#x3D;keyToVal.remove(key);</span><br><span class="line">        keyToVal.put(key,val);</span><br><span class="line">        return val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>152. Maximum Product Subarray</title>
    <url>/2021/02/02/maxProduct/</url>
    <content><![CDATA[<p>Since there might be negative numbers in the array, we must keep a min_cur parameter in addition to max_cur and res(because the max product might be disrupted by a single negative number)  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxProduct(int[] nums) &#123;</span><br><span class="line">        if(nums.length&#x3D;&#x3D;0) return 0;</span><br><span class="line">        int min_cur&#x3D;nums[0];</span><br><span class="line">        int max_cur&#x3D;nums[0];</span><br><span class="line">        int res&#x3D;max_cur;</span><br><span class="line">        for(int i&#x3D;1;i&lt;nums.length;i++)&#123;</span><br><span class="line">            int cur&#x3D;nums[i];</span><br><span class="line">            int temp&#x3D;min_cur;&#x2F;&#x2F;important</span><br><span class="line">            min_cur&#x3D;Math.min(min_cur*cur,Math.min(cur,max_cur*cur));</span><br><span class="line">            max_cur&#x3D;Math.max(cur,Math.max(temp*cur,max_cur*cur));</span><br><span class="line">            res&#x3D;Math.max(max_cur,res);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>rob</title>
    <url>/2021/02/02/rob/</url>
    <content><![CDATA[<h3 id="198"><a href="#198" class="headerlink" title="198"></a>198</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int rob(int[] nums) &#123;</span><br><span class="line">        int n&#x3D;nums.length;</span><br><span class="line">        if(n&#x3D;&#x3D;0) return 0;</span><br><span class="line">        int dp_i&#x3D;nums[0];</span><br><span class="line">        int dp_i_2&#x3D;0;</span><br><span class="line">        int dp_i_1&#x3D;nums[0];</span><br><span class="line">        for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            dp_i&#x3D;Math.max(dp_i_1,dp_i_2+nums[i-1]);</span><br><span class="line">            dp_i_2&#x3D;dp_i_1;</span><br><span class="line">            dp_i_1&#x3D;dp_i;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp_i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="337"><a href="#337" class="headerlink" title="337"></a>337</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int rob(TreeNode root) &#123;</span><br><span class="line">        int[] res&#x3D;dfs(root);</span><br><span class="line">        return Math.max(res[0],res[1]);&#x2F;&#x2F;0 means not rob, 1 means rob</span><br><span class="line">    &#125;</span><br><span class="line">    private int[] dfs(TreeNode root)&#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null) return new int[]&#123;0,0&#125;;</span><br><span class="line">        int[] left&#x3D;dfs(root.left);</span><br><span class="line">        int[] right&#x3D;dfs(root.right);</span><br><span class="line">        int[] res&#x3D;new int[2];</span><br><span class="line">        res[0]&#x3D;Math.max(left[0],left[1])+Math.max(right[0],right[1]);&#x2F;&#x2F;important</span><br><span class="line">        res[1]&#x3D;left[0]+right[0]+root.val;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>148. Sort List</title>
    <url>/2021/02/02/sortList148/</url>
    <content><![CDATA[<p>Using the idea of merge sort.<br>Notice that we split the linked list into two by pointing the last node of first half to null.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode sortList(ListNode head) &#123;</span><br><span class="line">        if(head&#x3D;&#x3D;null||head.next&#x3D;&#x3D;null) return head;</span><br><span class="line">        ListNode mid&#x3D;getMid(head);</span><br><span class="line">        ListNode left&#x3D;sortList(head);</span><br><span class="line">        ListNode right&#x3D;sortList(mid);</span><br><span class="line">        return merge(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">    private ListNode getMid(ListNode head)&#123;</span><br><span class="line">        ListNode fast&#x3D;head;</span><br><span class="line">        ListNode slow&#x3D;head;</span><br><span class="line">        ListNode midPrev&#x3D;null;</span><br><span class="line">        while(fast!&#x3D;null&amp;&amp;fast.next!&#x3D;null)&#123;</span><br><span class="line">            midPrev&#x3D;midPrev&#x3D;&#x3D;null?head:midPrev.next;</span><br><span class="line">            fast&#x3D;fast.next.next;</span><br><span class="line">            slow&#x3D;slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        midPrev.next&#x3D;null;&#x2F;&#x2F;important</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line">    private ListNode merge(ListNode n1,ListNode n2)&#123;</span><br><span class="line">        ListNode dummyHead&#x3D;new ListNode();</span><br><span class="line">        ListNode cur&#x3D;dummyHead;</span><br><span class="line">        while(n1!&#x3D;null&amp;&amp;n2!&#x3D;null)&#123;</span><br><span class="line">            if(n1.val&lt;n2.val)&#123;</span><br><span class="line">                cur.next&#x3D;n1;</span><br><span class="line">                n1&#x3D;n1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                cur.next&#x3D;n2;</span><br><span class="line">                n2&#x3D;n2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur&#x3D;cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next&#x3D;n1&#x3D;&#x3D;null?n2:n1;</span><br><span class="line">        return dummyHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>208. Implement Trie (Prefix Tree)</title>
    <url>/2021/02/02/trie/</url>
    <content><![CDATA[<p>The structure of this data structure is shown below:<br><img src="/images/post_images/trie_diagram.png">  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Trie &#123;</span><br><span class="line">    TrieNode root;</span><br><span class="line">    &#x2F;** Initialize your data structure here. *&#x2F;</span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        root&#x3D;new TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Inserts a word into the trie. *&#x2F;</span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        TrieNode cur&#x3D;root;</span><br><span class="line">        for(char c:word.toCharArray())&#123;</span><br><span class="line">            if(!cur.containsKey(c))&#123;</span><br><span class="line">                cur.put(c,new TrieNode());</span><br><span class="line">            &#125;</span><br><span class="line">            cur&#x3D;cur.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        cur.setEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Returns if the word is in the trie. *&#x2F;</span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        TrieNode cur&#x3D;root;</span><br><span class="line">        for(char c:word.toCharArray())&#123;</span><br><span class="line">            if(!cur.containsKey(c)) return false;</span><br><span class="line">            cur&#x3D;cur.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return cur!&#x3D;null&amp;&amp;cur.isEnd();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;** Returns if there is any word in the trie that starts with the given prefix. *&#x2F;</span><br><span class="line">    public boolean startsWith(String prefix) &#123;</span><br><span class="line">        TrieNode cur&#x3D;root;</span><br><span class="line">        for(char c:prefix.toCharArray())&#123;</span><br><span class="line">            if(!cur.containsKey(c)) return false;</span><br><span class="line">            cur&#x3D;cur.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class TrieNode&#123;</span><br><span class="line">    private TrieNode[] list&#x3D;new TrieNode[26];</span><br><span class="line">    private boolean isEnd;</span><br><span class="line">    public boolean containsKey(char ch)&#123;</span><br><span class="line">        return list[ch-&#39;a&#39;]!&#x3D;null;</span><br><span class="line">    &#125;</span><br><span class="line">    public TrieNode get(char ch)&#123;</span><br><span class="line">        return list[ch-&#39;a&#39;];</span><br><span class="line">    &#125;</span><br><span class="line">    public void put(char ch,TrieNode node)&#123;</span><br><span class="line">        list[ch-&#39;a&#39;]&#x3D;node;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setEnd()&#123;</span><br><span class="line">        isEnd&#x3D;true;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean isEnd()&#123;</span><br><span class="line">        return isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>design</tag>
      </tags>
  </entry>
  <entry>
    <title>221. Maximal Square</title>
    <url>/2021/02/03/maximalSquare/</url>
    <content><![CDATA[<p>dp[i][j] means the perimeter of the square containing only 1’s whose bottom right element is (i,j)  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int c(char[][] matrix) &#123;</span><br><span class="line">        int m&#x3D;matrix.length;</span><br><span class="line">        int n&#x3D;matrix[0].length;</span><br><span class="line">        int[] dp&#x3D;new int[n+1];</span><br><span class="line">        int maxlen&#x3D;0;</span><br><span class="line">        int prev&#x3D;0;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;m;i++)&#123;</span><br><span class="line">            prev&#x3D;0;</span><br><span class="line">            for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;</span><br><span class="line">                int temp&#x3D;dp[j];</span><br><span class="line">                if(matrix[i-1][j-1]&#x3D;&#x3D;&#39;1&#39;) &#123;</span><br><span class="line">                &#x2F;&#x2F;dp[i][j]&#x3D;Math.min(dp[i][j-1],Math.min(dp[i-1][j],dp[i-1][j-1]))+1;</span><br><span class="line">                dp[j]&#x3D;Math.min(prev,Math.min(dp[j],dp[j-1]))+1;</span><br><span class="line">                maxlen&#x3D;Math.max(dp[j],maxlen);</span><br><span class="line">                &#125;else</span><br><span class="line">                &#123;</span><br><span class="line">                dp[j]&#x3D;0;&#x2F;&#x2F;Notice that if we wanna compress the space to 1-D, we must update every element in the array in every new scan.</span><br><span class="line">                &#125;</span><br><span class="line">                prev&#x3D;temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxlen*maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>lowestCommonAncestor</title>
    <url>/2021/02/03/lowestCommonAncestor/</url>
    <content><![CDATA[<ul>
<li><p>The definition of this recursive function  </p>
<ul>
<li>If p and q are both descendants of root, return their lowest ancestor</li>
<li>If neither p or q is descendant of root, return null</li>
<li>If only one of p and q is descendent of root, return that node.  </li>
</ul>
</li>
<li><p>How to process the result we get from recursion  </p>
<ul>
<li>If left and right are both not null, it means root is the common ancestor, we should return root.  </li>
<li>If left and right are both null, it means neither p or q is descendant of root, we should return null.  </li>
<li>If only one of left and right is null, return the non-empty node.  </li>
</ul>
</li>
</ul>
<p>The guarantee of the condition ‘lowest’ is that we are doing it in postorder(down to top).  </p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if(root&#x3D;&#x3D;p||root&#x3D;&#x3D;q||root&#x3D;&#x3D;null) return root;</span><br><span class="line">        TreeNode left&#x3D;lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right&#x3D;lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        if(left!&#x3D;null&amp;&amp;right!&#x3D;null) return root;</span><br><span class="line">        if(left&#x3D;&#x3D;null&amp;&amp;right!&#x3D;null) return right;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>depth first search</tag>
      </tags>
  </entry>
  <entry>
    <title>Bit Manipulation</title>
    <url>/2021/02/03/bit-manipulation/</url>
    <content><![CDATA[<ul>
<li><p>n&amp;(n-1) could eliminate the last 1 of the binary representation of number n.  </p>
<ul>
<li><ol start="191">
<li>Number of 1 Bits<br>Eleminate the last 1 until it reaches 0, the number of manipulation will be the answer  </li>
</ol>
</li>
<li><ol start="231">
<li>Power of Two<br>If the number is zero or the result after eliminating once the last 1 is zero, return true  </li>
</ol>
</li>
<li><ol start="338">
<li>Counting Bits<br>The same trick could apply here combined with dynamic programming  </li>
</ol>
</li>
</ul>
</li>
<li><p> a ^ a = 0, a ^ 0 = a  </p>
</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>problem solving template</tag>
        <tag>leetcode</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>253. Meeting Rooms II</title>
    <url>/2021/02/03/minMeetingRooms/</url>
    <content><![CDATA[<ul>
<li>The main idea here is that we are not really concerned with which meeting has ended. All we need is that some meeting ended thus making a room available. </li>
<li>We put the start time and end time into two seperate arrays and sort them in ascending order. When we encounter an ending event, that means that some meeting that started earlier has ended now.   </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minMeetingRooms(int[][] intervals) &#123;</span><br><span class="line">        int n&#x3D;intervals.length;</span><br><span class="line">        int[] start&#x3D;new int[n];</span><br><span class="line">        int[] end&#x3D;new int[n];</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">            start[i]&#x3D;intervals[i][0];</span><br><span class="line">            end[i]&#x3D;intervals[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(start);</span><br><span class="line">        Arrays.sort(end);</span><br><span class="line">        int sp&#x3D;0;</span><br><span class="line">        int ep&#x3D;0;</span><br><span class="line">        int num&#x3D;0;</span><br><span class="line">        while(sp&lt;n)&#123;</span><br><span class="line">            if(start[sp]&gt;&#x3D;end[ep])&#123;</span><br><span class="line">                ep++;</span><br><span class="line">                num--;</span><br><span class="line">            &#125;</span><br><span class="line">            sp++;</span><br><span class="line">            num++;&#x2F;&#x2F;If a room got free, then this used_rooms +&#x3D; 1 wouldn&#39;t have any effect. used_rooms would remain the same in that case. If no room was free, then this would increase used_rooms</span><br><span class="line">        &#125;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>238. Product of Array Except Self</title>
    <url>/2021/02/03/productExceptSelf/</url>
    <content><![CDATA[<p>The idea is that product of array except self equals to product of left and product of right.<br>We can have two array to keep product of left and product of right of each element.<br>But we can also do it in O(1) space. We can first save the product of left in answer array. Then loop through the array from right to left and update a variable product of right to do the computation.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] productExceptSelf(int[] nums) &#123;</span><br><span class="line">        int n&#x3D;nums.length;</span><br><span class="line">        int[] ans&#x3D;new int[n];</span><br><span class="line">        if(n&#x3D;&#x3D;0) return ans;</span><br><span class="line">        ans[0]&#x3D;1;</span><br><span class="line">        for(int i&#x3D;1;i&lt;n;i++)&#123;</span><br><span class="line">            ans[i]&#x3D;ans[i-1]*nums[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        int pr&#x3D;1;</span><br><span class="line">        for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">            ans[i]*&#x3D;pr;</span><br><span class="line">            pr*&#x3D;nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>240. Search a 2D Matrix II</title>
    <url>/2021/02/03/searchMatrix/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean searchMatrix(int[][] matrix, int target) &#123;</span><br><span class="line">        int m&#x3D;matrix.length-1;</span><br><span class="line">        int n&#x3D;matrix[0].length-1;</span><br><span class="line">        int i&#x3D;m,j&#x3D;0;</span><br><span class="line">        while(i&gt;&#x3D;0&amp;&amp;j&lt;&#x3D;n)&#123;</span><br><span class="line">            if(matrix[i][j]&#x3D;&#x3D;target) return true;</span><br><span class="line">            if(matrix[i][j]&lt;target)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>divide and conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>416. Partition Equal Subset Sum</title>
    <url>/2021/02/04/canPartition/</url>
    <content><![CDATA[<p>We can transform it into a backpack problem by interpreting the requirement to is it possible that there is a subset in the array whose sum is half the total sum.<br>In this way we can solve it with dynamic programming. dp[i][j] means that for the first i elements, is it possible that there is a subset in the array whose sum is j.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canPartition(int[] nums) &#123;</span><br><span class="line">        int sum&#x3D;0;</span><br><span class="line">        for(int i:nums)&#123;</span><br><span class="line">            sum+&#x3D;i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum%2!&#x3D;0) return false;</span><br><span class="line">        &#x2F;&#x2F;boolean[][] dp&#x3D;new boolean[nums.length+1][sum&#x2F;2+1];</span><br><span class="line">        boolean[] dp&#x3D;new boolean[sum&#x2F;2+1];</span><br><span class="line">        &#x2F;&#x2F;for(int i&#x3D;0;i&lt;&#x3D;nums.length;i++) dp[i][0]&#x3D;true;</span><br><span class="line">        dp[0]&#x3D;true;</span><br><span class="line">        for(int i&#x3D;1;i&lt;&#x3D;nums.length;i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;for(int j&#x3D;1;j&lt;&#x3D;sum&#x2F;2;j++)&#123;</span><br><span class="line">            for(int j&#x3D;sum&#x2F;2;j&gt;&#x3D;1;j--)&#123;&#x2F;&#x2F;Notice that we need to iterate from back to forth, to prevent former dp[j-nums[i-1]] to be covered.</span><br><span class="line">                &#x2F;&#x2F; if(j-nums[i-1]&lt;0)&#123;</span><br><span class="line">                &#x2F;&#x2F;     dp[i][j]&#x3D;dp[i-1][j];</span><br><span class="line">                &#x2F;&#x2F; &#125;</span><br><span class="line">                &#x2F;&#x2F; else&#123;</span><br><span class="line">                &#x2F;&#x2F;     dp[i][j]&#x3D;dp[i-1][j]||dp[i-1][j-nums[i-1]];</span><br><span class="line">                &#x2F;&#x2F; &#125;</span><br><span class="line">                if(j-nums[i-1]&gt;&#x3D;0)&#123;</span><br><span class="line">                    dp[j]&#x3D;dp[j]||dp[j-nums[i-1]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        return dp[sum&#x2F;2];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>438. Find All Anagrams in a String</title>
    <url>/2021/02/04/findAnagrams/</url>
    <content><![CDATA[<p>This problem is pretty similar to 49.   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line">        int lens&#x3D;s.length();</span><br><span class="line">        int lenp&#x3D;p.length();</span><br><span class="line">        if(lenp&gt;lens) return new ArrayList();</span><br><span class="line">        List&lt;Integer&gt; res&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        int[] counts&#x3D;new int[26];</span><br><span class="line">        int[] countp&#x3D;new int[26];</span><br><span class="line">        for(char c:p.toCharArray())&#123;</span><br><span class="line">            countp[c-&#39;a&#39;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;0;i&lt;lens;i++)&#123;</span><br><span class="line">            char c&#x3D;s.charAt(i);</span><br><span class="line">            counts[c-&#39;a&#39;]++;</span><br><span class="line">            if(i&gt;&#x3D;lenp)&#123;</span><br><span class="line">                counts[s.charAt(i-lenp)-&#39;a&#39;]--;</span><br><span class="line">            &#125;</span><br><span class="line">            if(Arrays.equals(counts,countp))&#123;</span><br><span class="line">                res.add(i-lenp+1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>437. Path Sum III</title>
    <url>/2021/02/04/pathSum/</url>
    <content><![CDATA[<ul>
<li><p>prefix sum<br><img src="/images/post_images/sumpath_diagram1.png"><br>prefix[i] means the sum of num[0…i-1], so prefix[j+1] - prefix[i]=num[i…j].  </p>
</li>
<li><p>In this problem we could keep all the prefixes of all the nodes along the way in preorder and remove them in postorder. We need to store the prefix and the corresponding times it appears in a hashmap.  </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int count&#x3D;0;</span><br><span class="line">    int target;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; hm&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">    public int pathSum(TreeNode root, int sum) &#123;</span><br><span class="line">        target&#x3D;sum;</span><br><span class="line">        hm.put(0,1);</span><br><span class="line">        dfs(root,0);</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    private void dfs(TreeNode root,int cursum)&#123;</span><br><span class="line">        if(root&#x3D;&#x3D;null) return;</span><br><span class="line">        cursum+&#x3D;root.val;</span><br><span class="line">        count+&#x3D;hm.getOrDefault(cursum-target,0);</span><br><span class="line">        hm.put(cursum,hm.getOrDefault(cursum,0)+1);</span><br><span class="line">        dfs(root.left,cursum);</span><br><span class="line">        dfs(root.right,cursum);</span><br><span class="line">        hm.put(cursum,hm.get(cursum)-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>depth first search</tag>
        <tag>prefix sum</tag>
      </tags>
  </entry>
  <entry>
    <title>Quick Find</title>
    <url>/2021/02/04/quickfind/</url>
    <content><![CDATA[<ul>
<li>core: the realisation of partition algorithm  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int partition(int[] nums, int lo, int hi) &#123;</span><br><span class="line">    if (lo &#x3D;&#x3D; hi) return lo;</span><br><span class="line">    &#x2F;&#x2F; nums[lo] is our default pivot</span><br><span class="line">    int pivot &#x3D; nums[lo];</span><br><span class="line">    &#x2F;&#x2F; j &#x3D; hi + 1 cuz -- will be executed first</span><br><span class="line">    int i &#x3D; lo, j &#x3D; hi + 1;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        &#x2F;&#x2F; guarantee that nums[lo..i] &lt; pivot</span><br><span class="line">        while (nums[++i] &lt; pivot) &#123;</span><br><span class="line">            if (i &#x3D;&#x3D; hi) break;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; guarantee that nums[j..hi] &gt;&#x3D; pivot</span><br><span class="line">        while (nums[--j] &gt;&#x3D; pivot) &#123;</span><br><span class="line">            if (j &#x3D;&#x3D; lo) break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &gt;&#x3D; j) break;</span><br><span class="line">        &#x2F;&#x2F; If we make it to this point, the following must be true：</span><br><span class="line">        &#x2F;&#x2F; nums[i] &gt;&#x3D; pivot &amp;&amp; nums[j] &lt; pivot</span><br><span class="line">        &#x2F;&#x2F; So we need to exchange nums[i] and nums[j]，</span><br><span class="line">        &#x2F;&#x2F; to make sure that nums[lo..i] &lt; pivot &lt;&#x3D; nums[j..hi]</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; To exchange pivot to the right position</span><br><span class="line">    swap(nums, j, lo);</span><br><span class="line">    &#x2F;&#x2F; Now nums[lo..j-1] &lt; nums[j] &lt;&#x3D; nums[j+1..hi]</span><br><span class="line">    return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">    int temp &#x3D; nums[i];</span><br><span class="line">    nums[i] &#x3D; nums[j];</span><br><span class="line">    nums[j] &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="215"><a href="#215" class="headerlink" title="215"></a>215</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">    int lo &#x3D; 0, hi &#x3D; nums.length - 1;</span><br><span class="line">    &#x2F;&#x2F; change the index</span><br><span class="line">    k &#x3D; nums.length - k;</span><br><span class="line">    while (lo &lt;&#x3D; hi) &#123;</span><br><span class="line">        &#x2F;&#x2F; Find a pivot in nums[lo..hi] </span><br><span class="line">        int p &#x3D; partition(nums, lo, hi);</span><br><span class="line">        if (p &lt; k) &#123;</span><br><span class="line">            &#x2F;&#x2F; the kth largest element is in nums[p+1..hi] </span><br><span class="line">            lo &#x3D; p + 1;</span><br><span class="line">        &#125; else if (p &gt; k) &#123;</span><br><span class="line">            &#x2F;&#x2F; the kth largest element is in nums[lo..p-1] </span><br><span class="line">            hi &#x3D; p - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; Found</span><br><span class="line">            return nums[p];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="347"><a href="#347" class="headerlink" title="347"></a>347</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; hm&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">    public int[] topKFrequent(int[] nums, int k) &#123;</span><br><span class="line">        int n&#x3D;nums.length;</span><br><span class="line">        </span><br><span class="line">        for(int i:nums)&#123;</span><br><span class="line">            hm.put(i,hm.getOrDefault(i,0)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        n&#x3D;hm.size();</span><br><span class="line">        int[] unique&#x3D;new int[n];</span><br><span class="line">        k&#x3D;n-k;</span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        for(int num:hm.keySet())&#123;</span><br><span class="line">            unique[i++]&#x3D;num;</span><br><span class="line">        &#125;</span><br><span class="line">        int lo&#x3D;0;</span><br><span class="line">        int hi&#x3D;n-1;</span><br><span class="line">        while(lo&lt;&#x3D;hi)&#123;</span><br><span class="line">            int p&#x3D;partition(unique,lo,hi);</span><br><span class="line">            if(p&gt;k)&#123;</span><br><span class="line">                hi&#x3D;p-1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(p&lt;k)&#123;</span><br><span class="line">                lo&#x3D;p+1;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Arrays.copyOfRange(unique,k,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>quick find</tag>
      </tags>
  </entry>
  <entry>
    <title>394. Decode String</title>
    <url>/2021/02/04/decodeString/</url>
    <content><![CDATA[<ul>
<li>Keep in mind the recursive nature of brackets, which is core in solving problems like this.  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String decodeString(String s) &#123;</span><br><span class="line">        StringBuilder str&#x3D;new StringBuilder(s);</span><br><span class="line">        str.reverse();</span><br><span class="line">        return helper(str).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    private StringBuilder helper(StringBuilder s)&#123;</span><br><span class="line">        int n&#x3D;0;</span><br><span class="line">        StringBuilder ns&#x3D;new StringBuilder();</span><br><span class="line">        while(s.length()!&#x3D;0)&#123;</span><br><span class="line">            char c&#x3D;s.charAt(s.length()-1);</span><br><span class="line">            s.deleteCharAt(s.length()-1);</span><br><span class="line">            if(Character.isDigit(c))&#123;</span><br><span class="line">                n&#x3D;n*10+c-&#39;0&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(c&#x3D;&#x3D;&#39;[&#39;)&#123;</span><br><span class="line">                StringBuilder str&#x3D;helper(s);</span><br><span class="line">                for(int i&#x3D;n;i&gt;0;i--)&#123;</span><br><span class="line">                    ns.append(str);</span><br><span class="line">                &#125;</span><br><span class="line">                n&#x3D;0;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(c&#x3D;&#x3D;&#39;]&#39;)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                ns.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>recursion</tag>
      </tags>
  </entry>
  <entry>
    <title>406. Queue Reconstruction by Height</title>
    <url>/2021/02/04/reconstructQueue/</url>
    <content><![CDATA[<p>The idea here is that smaller people are invisible to taller people, so once we’ve sorted them in descending order by their height, we can do it iteratively.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] reconstructQueue(int[][] people) &#123;</span><br><span class="line">        int n&#x3D;people.length;</span><br><span class="line">        Arrays.sort(people,new Comparator&lt;int[]&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(int[] a,int[] b)&#123;</span><br><span class="line">                return a[0]&#x3D;&#x3D;b[0]?a[1]-b[1]:b[0]-a[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;int[]&gt; res&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        for(int[] person:people)&#123;</span><br><span class="line">            res.add(person[1],person);</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toArray(new int[n][2]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>findTargetSumWays</title>
    <url>/2021/02/04/findTargetSumWays/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    HashMap&lt;String,Integer&gt; mem&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">    int n;</span><br><span class="line">    public int findTargetSumWays(int[] nums, int S) &#123;</span><br><span class="line">        n&#x3D;nums.length;</span><br><span class="line">        return ways(nums,S,0);</span><br><span class="line">    &#125;</span><br><span class="line">    private int ways(int[] nums,int res,int pos)&#123;</span><br><span class="line">        if(pos&#x3D;&#x3D;n)&#123;</span><br><span class="line">            return res&#x3D;&#x3D;0?1:0;</span><br><span class="line">        &#125;</span><br><span class="line">        String key&#x3D;res+&quot;*&quot;+pos;</span><br><span class="line">        if(mem.containsKey(key))&#123;</span><br><span class="line">            return mem.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        int num&#x3D;ways(nums,res+nums[pos],pos+1)+ways(nums,res-nums[pos],pos+1);</span><br><span class="line">        mem.put(key,num);</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>560. Subarray Sum Equals K</title>
    <url>/2021/02/04/subarraySum/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int subarraySum(int[] nums, int k) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hm&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">        hm.put(0,1);</span><br><span class="line">        int prefix&#x3D;0;</span><br><span class="line">        int res&#x3D;0;</span><br><span class="line">        for(int num:nums)&#123;</span><br><span class="line">            prefix+&#x3D;num;            </span><br><span class="line">            res+&#x3D;hm.getOrDefault(prefix-k,0);&#x2F;&#x2F;notice we should first search hm then update it, cuz you can only search for the prefixes before you.</span><br><span class="line">            hm.put(prefix,hm.getOrDefault(prefix,0)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>prefix sum</tag>
      </tags>
  </entry>
  <entry>
    <title>621. Task Scheduler</title>
    <url>/2021/02/05/leastInterval/</url>
    <content><![CDATA[<ul>
<li>total=idle+busy(length of the tasks) </li>
<li>Maximum possible number of idle slots is defined by the frequency of the most frequent task: idle_time &lt;= (f_max - 1) * n.  </li>
<li>For other less or equally frequent tasks, idle_time-=max(f_max,f_self)  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int leastInterval(char[] tasks, int n) &#123;</span><br><span class="line">        int[] freq&#x3D;new int[26];</span><br><span class="line">        for(char t:tasks)&#123;</span><br><span class="line">            freq[t-&#39;A&#39;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(freq);</span><br><span class="line">        int fmax&#x3D;freq[25];</span><br><span class="line">        int idle&#x3D;(fmax-1)*n;</span><br><span class="line">        for(int i&#x3D;freq.length-2;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">            idle-&#x3D;Math.min(fmax-1,freq[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        idle&#x3D;Math.max(0,idle);</span><br><span class="line">        return idle+tasks.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>countSubstrings</title>
    <url>/2021/02/05/countSubstrings/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countSubstrings(String s) &#123;</span><br><span class="line">        int n&#x3D;s.length();</span><br><span class="line">        int ans&#x3D;0;</span><br><span class="line">        if(n&#x3D;&#x3D;0) return 0;</span><br><span class="line">        boolean[][] dp&#x3D;new boolean[n][n];</span><br><span class="line">        for(int i&#x3D;0;i&lt;n;i++) &#123;</span><br><span class="line">            dp[i][i]&#x3D;true;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;&#x2F;&#x2F;count substring with single character</span><br><span class="line">        for(int i&#x3D;0;i&lt;n-1;i++)&#123;</span><br><span class="line">            dp[i][i+1]&#x3D;s.charAt(i)&#x3D;&#x3D;s.charAt(i+1);</span><br><span class="line">            ans+&#x3D;(dp[i][i+1]?1:0);</span><br><span class="line">        &#125;&#x2F;&#x2F;count substring with length equal to 2</span><br><span class="line">        for(int len&#x3D;2;len&lt;n;len++)&#123;</span><br><span class="line">            for(int i&#x3D;0,j&#x3D;i+len;j&lt;n;i++,j++)&#123;</span><br><span class="line">                dp[i][j]&#x3D;dp[i+1][j-1]&amp;&amp;s.charAt(i)&#x3D;&#x3D;s.charAt(j);</span><br><span class="line">                ans+&#x3D;(dp[i][j]?1:0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>dynamic programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Monotonic Stack</title>
    <url>/2021/02/05/monotonicstack/</url>
    <content><![CDATA[<h3 id="739"><a href="#739" class="headerlink" title="739"></a>739</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] dailyTemperatures(int[] T) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack&#x3D;new Stack&lt;&gt;();</span><br><span class="line">        int[] res&#x3D;new int[T.length];</span><br><span class="line">        for(int i&#x3D;T.length-1;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">            while(!stack.isEmpty()&amp;&amp;T[stack.peek()]&lt;&#x3D;T[i])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            res[i]&#x3D;stack.isEmpty()?0:stack.peek()-i;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>monotonic stack</tag>
      </tags>
  </entry>
  <entry>
    <title>partitionLabels</title>
    <url>/2021/02/05/partitionLabels/</url>
    <content><![CDATA[<ul>
<li>Maintain an array that keeps the index where each character appears last.  </li>
<li>Loop through the string, for every character we encounter, update the farthest index we can reach so far.  </li>
<li>If we are at the end of the partition (i == j) then we’ll append a partition size to our answer, and set the start of our new partition to i+1.  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; partitionLabels(String S) &#123;</span><br><span class="line">        int[] last&#x3D;new int[26];</span><br><span class="line">        for(int i&#x3D;0;i&lt;S.length();i++)&#123;</span><br><span class="line">            last[S.charAt(i)-&#39;a&#39;]&#x3D;i;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        int anchor&#x3D;0;</span><br><span class="line">        int j&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;S.length();i++)&#123;</span><br><span class="line">            j&#x3D;Math.max(j,last[S.charAt(i)-&#39;a&#39;]);</span><br><span class="line">            if(j&#x3D;&#x3D;i)&#123;</span><br><span class="line">                res.add(i-anchor+1);</span><br><span class="line">                anchor&#x3D;i+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>countAndSay</title>
    <url>/2021/02/06/countAndSay/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String countAndSay(int n) &#123;</span><br><span class="line">        String res&#x3D;&quot;1&quot;;</span><br><span class="line">        for(int i&#x3D;2;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">            res&#x3D;f(res);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    private String f(String s)&#123;</span><br><span class="line">        int count&#x3D;1;</span><br><span class="line">        char ch&#x3D;s.charAt(0);</span><br><span class="line">        StringBuilder sb&#x3D;new StringBuilder();</span><br><span class="line">        for(int i&#x3D;1;i&lt;s.length();i++)&#123;</span><br><span class="line">            if(s.charAt(i)!&#x3D;ch)&#123;</span><br><span class="line">                sb.append(count).append(ch);</span><br><span class="line">                ch&#x3D;s.charAt(i);</span><br><span class="line">                count&#x3D;1;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(count).append(ch);</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>longestCommonPrefix</title>
    <url>/2021/02/06/longestCommonPrefix/</url>
    <content><![CDATA[<p>My initial solution is as follows, it is basically vertical scanning but is pretty redundant.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if(strs&#x3D;&#x3D;null||strs.length&#x3D;&#x3D;0) return &quot;&quot;;</span><br><span class="line">        int i&#x3D;0;</span><br><span class="line">        StringBuilder res&#x3D;new StringBuilder();</span><br><span class="line">        boolean flag&#x3D;false;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            char prev&#x3D;&#39;\0&#39;;</span><br><span class="line">            for(String s:strs)&#123;</span><br><span class="line">                if(s.length()-1&lt;i)&#123;</span><br><span class="line">                    flag&#x3D;true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if(prev&#x3D;&#x3D;&#39;\0&#39;)&#123;</span><br><span class="line">                    prev&#x3D;s.charAt(i);</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    char cur&#x3D;s.charAt(i);</span><br><span class="line">                    if(cur!&#x3D;prev)&#123;</span><br><span class="line">                        flag&#x3D;true;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(flag) break;</span><br><span class="line">            res.append(prev);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>A cleaner code would be like this.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if(strs&#x3D;&#x3D;null||strs.length&#x3D;&#x3D;0) return &quot;&quot;;</span><br><span class="line">        for(int i&#x3D;0;i&lt;strs[0].length();i++)&#123;</span><br><span class="line">            char first&#x3D;strs[0].charAt(i);</span><br><span class="line">            for(int j&#x3D;1;j&lt;strs.length;j++)&#123;</span><br><span class="line">                if(strs[j].length()-1&lt;i||strs[j].charAt(i)!&#x3D;first)&#123;</span><br><span class="line">                    return strs[0].substring(0,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return strs[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>plusOne</title>
    <url>/2021/02/06/plusOne/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] plusOne(int[] digits) &#123;</span><br><span class="line">        int carry&#x3D;1;</span><br><span class="line">        for(int i&#x3D;digits.length-1;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">            int temp&#x3D;digits[i];</span><br><span class="line">            digits[i]&#x3D;(digits[i]+carry)%10;</span><br><span class="line">            carry&#x3D;(temp+carry)&#x2F;10;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry!&#x3D;0)&#123;</span><br><span class="line">            int[] res&#x3D;new int[digits.length+1];</span><br><span class="line">            res[0]&#x3D;1;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        return digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>7. Reverse Integer</title>
    <url>/2021/02/06/reverse7/</url>
    <content><![CDATA[<p>We want to repeatedly “pop” the last digit off of xx and “push” it to the back of the \text{rev}rev. In the end, \text{rev}rev will be the reverse of the xx.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int reverse(int x) &#123;</span><br><span class="line">        int rev&#x3D;0;</span><br><span class="line">        while(x!&#x3D;0)&#123;</span><br><span class="line">            int pop&#x3D;x%10;</span><br><span class="line">            x&#x3D;x&#x2F;10;</span><br><span class="line">            if(rev&gt;Integer.MAX_VALUE&#x2F;10||rev&#x3D;&#x3D;Integer.MAX_VALUE&amp;&amp;pop&gt;7) return 0;</span><br><span class="line">            if(rev&lt;Integer.MIN_VALUE&#x2F;10||rev&#x3D;&#x3D;Integer.MIN_VALUE&amp;&amp;pop&lt;-8) return 0;</span><br><span class="line">            rev&#x3D;rev*10+pop;</span><br><span class="line">        &#125;</span><br><span class="line">        return rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>13. Roman to Integer</title>
    <url>/2021/02/06/romanToInt/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int romanToInt(String s) &#123;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; symToVal&#x3D;new HashMap&lt;&gt;();</span><br><span class="line">        symToVal.put(&#39;I&#39;,1);</span><br><span class="line">        symToVal.put(&#39;V&#39;,5);</span><br><span class="line">        symToVal.put(&#39;X&#39;,10);</span><br><span class="line">        symToVal.put(&#39;L&#39;,50);</span><br><span class="line">        symToVal.put(&#39;C&#39;,100);</span><br><span class="line">        symToVal.put(&#39;D&#39;,500);</span><br><span class="line">        symToVal.put(&#39;M&#39;,1000);</span><br><span class="line">        int prev&#x3D;symToVal.get(s.charAt(s.length()-1));</span><br><span class="line">        int res&#x3D;symToVal.get(s.charAt(s.length()-1));</span><br><span class="line">        for(int i&#x3D;s.length()-2;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">            int cur&#x3D;symToVal.get(s.charAt(i));</span><br><span class="line">            if(cur&lt;prev) res-&#x3D;cur;</span><br><span class="line">            else&#123;</span><br><span class="line">                res+&#x3D;cur;</span><br><span class="line">            &#125;</span><br><span class="line">            prev&#x3D;cur;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>118. Pascal&#39;s Triangle</title>
    <url>/2021/02/07/generate/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">        if (numRows&#x3D;&#x3D;0) return res;</span><br><span class="line">        res.add(new ArrayList&lt;&gt;());</span><br><span class="line">        res.get(0).add(1);</span><br><span class="line">        for(int i&#x3D;1;i&lt;numRows;i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; row&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">            List&lt;Integer&gt; prevrow&#x3D;res.get(i-1);</span><br><span class="line">            row.add(1);</span><br><span class="line">            for(int j&#x3D;1;j&lt;i;j++)&#123;</span><br><span class="line">                row.add(prevrow.get(j-1)+prevrow.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            row.add(1);</span><br><span class="line">            res.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>163. Missing Ranges</title>
    <url>/2021/02/10/findMissingRanges/</url>
    <content><![CDATA[<p>Notice that we could build a function to encapsulate the code block that does the same thing.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; findMissingRanges(int[] nums, int lower, int upper) &#123;</span><br><span class="line">        int bound&#x3D;lower;</span><br><span class="line">        List&lt;String&gt; res&#x3D;new LinkedList&lt;&gt;();</span><br><span class="line">        for(int num:nums)&#123;</span><br><span class="line">            &#x2F;&#x2F; if(num&#x3D;&#x3D;bound+1)&#123;</span><br><span class="line">            &#x2F;&#x2F;     res.add(String.valueOf(bound));</span><br><span class="line">            &#x2F;&#x2F; &#125;</span><br><span class="line">            &#x2F;&#x2F; else if(num&gt;bound+1)&#123;</span><br><span class="line">            &#x2F;&#x2F;     res.add(bound+&quot;-&gt;&quot;+(num-1));</span><br><span class="line">            &#x2F;&#x2F; &#125;</span><br><span class="line">            if(num&gt;&#x3D;bound+1)&#123;</span><br><span class="line">                res.add(formatRange(bound,num-1));</span><br><span class="line">            &#125;</span><br><span class="line">            bound&#x3D;num+1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; if(upper&#x3D;&#x3D;bound)&#123;</span><br><span class="line">        &#x2F;&#x2F;     res.add(String.valueOf(upper));</span><br><span class="line">        &#x2F;&#x2F; &#125;</span><br><span class="line">        &#x2F;&#x2F; if(bound&lt;upper)&#123;</span><br><span class="line">        &#x2F;&#x2F;     res.add(bound+&quot;-&gt;&quot;+upper);</span><br><span class="line">        &#x2F;&#x2F; &#125;</span><br><span class="line">        if(upper&gt;&#x3D;bound)&#123;</span><br><span class="line">            res.add(formatRange(bound,upper));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    String formatRange(int lower,int upper)&#123;</span><br><span class="line">        if(lower&#x3D;&#x3D;upper)&#123;</span><br><span class="line">            return String.valueOf(lower);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return lower+&quot;-&gt;&quot;+upper;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>88. Merge Sorted Array</title>
    <url>/2021/02/06/merge88/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">        int p1&#x3D;m-1;</span><br><span class="line">        int p2&#x3D;n-1;</span><br><span class="line">        for(int p&#x3D;m+n-1;p&gt;&#x3D;0;p--)&#123;</span><br><span class="line">            int n1&#x3D;p1&gt;&#x3D;0?nums1[p1]:Integer.MIN_VALUE;</span><br><span class="line">            int n2&#x3D;p2&gt;&#x3D;0?nums2[p2]:Integer.MIN_VALUE;</span><br><span class="line">            if(n1&gt;n2)&#123;</span><br><span class="line">                p1--;</span><br><span class="line">                nums1[p]&#x3D;n1;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                p2--;</span><br><span class="line">                nums1[p]&#x3D;n2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>69. Sqrt(x)</title>
    <url>/2021/02/06/mySqrt/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int mySqrt(int x) &#123;</span><br><span class="line">        if(x&lt;2) return x;</span><br><span class="line">        int left&#x3D;0;</span><br><span class="line">        int right&#x3D;x&#x2F;2;</span><br><span class="line">        int pivot;</span><br><span class="line">        long num;</span><br><span class="line">        while(left&lt;&#x3D;right)&#123;</span><br><span class="line">            pivot&#x3D;left+(right-left)&#x2F;2;</span><br><span class="line">            num&#x3D;(long)pivot*pivot;</span><br><span class="line">            if(num&gt;x)&#123;</span><br><span class="line">                right&#x3D;pivot-1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(num&lt;x)&#123;</span><br><span class="line">                left&#x3D;pivot+1;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                return pivot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>binary search</tag>
      </tags>
  </entry>
  <entry>
    <title>204. Count Primes</title>
    <url>/2021/02/10/countPrimes/</url>
    <content><![CDATA[<p>The time complexity of brute-force method of this question is O(n^2).<br>So the first optimization is to adopt the method of exclusion.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int countPrimes(int n) &#123;</span><br><span class="line">    boolean[] isPrim &#x3D; new boolean[n];</span><br><span class="line">    &#x2F;&#x2F; 将数组都初始化为 true</span><br><span class="line">    Arrays.fill(isPrim, true);</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 2; i &lt; n; i++) </span><br><span class="line">        if (isPrim[i]) </span><br><span class="line">            &#x2F;&#x2F; i 的倍数不可能是素数了</span><br><span class="line">            for (int j &#x3D; 2 * i; j &lt; n; j +&#x3D; i) </span><br><span class="line">                    isPrim[j] &#x3D; false;</span><br><span class="line"></span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 2; i &lt; n; i++)</span><br><span class="line">        if (isPrim[i]) count++;</span><br><span class="line"></span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>There are still two places that can be optimized in the above code.    </p>
<ul>
<li>First, we can change the ending condition of exterior loop to i*i&lt;n(because of the symmetry of factors)</li>
<li>Secondly, the starting condition of interior loop can be changed to j=i*i to avoid repetitive calculations.  </li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>202. Happy Number</title>
    <url>/2021/02/10/isHappy/</url>
    <content><![CDATA[<p>It’s basically the same idea of detecting linked cycle.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isHappy(int n) &#123;</span><br><span class="line">        int fast&#x3D;happy(n);</span><br><span class="line">        int slow&#x3D;fast;</span><br><span class="line">        while(fast!&#x3D;1)&#123;</span><br><span class="line">            fast&#x3D;happy(happy(fast));</span><br><span class="line">            slow&#x3D;happy(slow);</span><br><span class="line">            if(fast!&#x3D;1&amp;&amp;fast&#x3D;&#x3D;slow)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    private int happy(int n)&#123;</span><br><span class="line">        int res&#x3D;0;</span><br><span class="line">        while(n!&#x3D;0)&#123;</span><br><span class="line">            res+&#x3D;Math.pow(n%10,2);</span><br><span class="line">            n&#x2F;&#x3D;10;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>190. Reverse Bits</title>
    <url>/2021/02/10/reverseBits/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    &#x2F;&#x2F; you need treat n as an unsigned value</span><br><span class="line">    public int reverseBits(int n) &#123;</span><br><span class="line">        int ans&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;32;i++)&#123;</span><br><span class="line">            ans&lt;&lt;&#x3D;1;</span><br><span class="line">            ans|&#x3D;n&amp;1;&#x2F;&#x2F;ans+&#x3D;n&amp;1(notice n&amp;1 is to retrieve the last bit)</span><br><span class="line">            n&gt;&gt;&#x3D;1;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>bit manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title>172. Factorial Trailing Zeroes</title>
    <url>/2021/02/10/trailingZeroes/</url>
    <content><![CDATA[<p>This question is equal to finding the number of 5 in the factorial of n.<br>For example, for 125, we can do this:<br>125/5=25.(There are 25 5s in 125)<br>125/25(25/5)=5(There are 5 25s in 125)<br>125/125(5/5)=1(There is 1 125 in 125)<br>Because there are overlapping parts(125 is included in 25s and 5s,etc), the result would be 25+5+1=31.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int trailingZeroes(int n) &#123;</span><br><span class="line">        if(n&#x3D;&#x3D;0) return 0;</span><br><span class="line">        int count&#x3D;0;</span><br><span class="line">        while(n&#x2F;5!&#x3D;0)&#123;</span><br><span class="line">            count+&#x3D;n&#x2F;5;</span><br><span class="line">            n&#x2F;&#x3D;5;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>isPowerOfThree</title>
    <url>/2021/02/11/isPowerOfThree/</url>
    <content><![CDATA[<p>Knowing the limitation of n, we can now deduce that the maximum value of n that is also a power of three is 1162261467.<br>Therefore, the possible values of n where we should return true are 3^0, 3^1… 3^19. Since 3 is a prime number, the only divisors of 3^19 are 3^0, 3^1 … 3^19, therefore all we need to do is divide 3^19 by n. A remainder of 0 means n is a divisor of 3^19 and therefore a power of three.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isPowerOfThree(int n) &#123;</span><br><span class="line">        int max&#x3D;(int)Math.pow(3,(int)(Math.log10(Integer.MAX_VALUE)&#x2F;Math.log10(3)));</span><br><span class="line">        return n&gt;0&amp;&amp;max%n&#x3D;&#x3D;0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>servlet</title>
    <url>/2021/02/14/servlet/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
